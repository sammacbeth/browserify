"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _buffer = require("buffer");

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isUint8Array = value => value instanceof Uint8Array;

const Bind = {
  BIND_STATE_UNBOUND: 0,
  BIND_STATE_BINDING: 1,
  BIND_STATE_BOUND: 2
};

exports.default = lib => {
  class Socket extends _events2.default {
    constructor(type, listener) {
      super();

      if (type !== null && typeof type === "object") {
        var options = type;
        this.type = options.type;
        this.dns = options.lookup ? fromNodeLookup(options.lookup) : lib.dns;
        this._reuseAddr = !!options.reuseAddr;
      } else {
        this._reuseAddr = false;
        this.type = type;
        this.dns = lib.dns;
      }

      if (typeof listener === "function") {
        this.on("message", listener);
      }

      this.isIdle = true;
      this._handle = null;
      this._bindState = Bind.BIND_STATE_UNBOUND;
      this.workQueue = [];
    }
    _healthCheck() {
      if (!this._handle) {
        throw new ERR_SOCKET_DGRAM_NOT_RUNNING();
      }
      return this._handle;
    }

    send(buffer, ...args) {
      let [offset, length, port, address, callback] = args;
      let list;

      if (address || port && typeof port !== "function") {
        buffer = sliceBuffer(buffer, offset, length);
      } else {
        callback = port;
        port = offset;
        address = length;
      }

      if (!Array.isArray(buffer)) {
        if (typeof buffer === "string") {
          list = [_buffer.Buffer.from(buffer)];
        } else if (!isUint8Array(buffer)) {
          throw new ERR_INVALID_ARG_TYPE("buffer", ["Buffer", "Uint8Array", "string"], buffer);
        } else {
          list = [buffer];
        }
      } else if (!(list = fixBufferList(buffer))) {
        throw new ERR_INVALID_ARG_TYPE("buffer list arguments", ["Buffer", "string"], buffer);
      }

      port = port >>> 0;
      if (port === 0 || port > 65535) throw new ERR_SOCKET_BAD_PORT(port);

      if (typeof callback !== "function") callback = undefined;

      if (typeof address === "function") {
        callback = address;
        address = undefined;
      } else if (address && typeof address !== "string") {
        throw new ERR_INVALID_ARG_TYPE("address", ["string", "falsy"], address);
      }

      if (this._bindState === Bind.BIND_STATE_UNBOUND) {
        this.bind({ port: 0, exclusive: true }, null);
      }

      if (list.length === 0) {
        list.push(_buffer.Buffer.alloc(0));
      }

      const host = address || (this.type === "udp4" ? "127.0.0.1" : "::1");
      this.schedule(new Send(this, list, port, host, callback));
    }

    close(callback) {
      if (typeof callback === "function") {
        this.on("close", callback);
      }

      this.schedule(new Close(this));
    }

    schedule(task) {
      this.workQueue.push(task);
      if (this.isIdle) {
        this.awake();
      }
    }
    async awake() {
      if (this.isIdle) {
        this.isIdle = false;
        const { workQueue } = this;
        let index = 0;
        while (index < workQueue.length) {
          const task = workQueue[index++];
          await task.perform();
        }
        workQueue.length = 0;
        this.isIdle = true;
      }
    }

    address() {
      const { host, port, family } = this._healthCheck().address;
      return {
        address: host,
        host,
        port,
        family: toNodeFamily(family)
      };
    }

    setMulticastLoopback(flag) {
      const socket = this._healthCheck();

      try {
        lib.UDPSocket.setMulticastLoopback(socket, flag);
      } catch (error) {
        throw errnoException(error, "setMulticastLoopback");
      }
    }

    setMulticastInterface(interfaceAddress) {
      const socket = this._healthCheck();

      if (typeof interfaceAddress !== "string") {
        throw new ERR_INVALID_ARG_TYPE("interfaceAddress", "string", interfaceAddress);
      }

      try {
        lib.UDPSocket.setMulticastInterface(socket, interfaceAddress);
      } catch (error) {
        throw errnoException(error, "setMulticastInterface");
      }
    }

    setMulticastTTL(ttl) {}

    addMembership(multicastAddress, interfaceAddress) {
      const socket = this._healthCheck();

      if (!multicastAddress) {
        throw new ERR_MISSING_ARGS("multicastAddress");
      }

      try {
        lib.UDPSocket.addMembership(socket, multicastAddress, interfaceAddress);
      } catch (error) {
        throw errnoException(error, "addMembership");
      }
    }
    dropMembership(multicastAddress, interfaceAddress) {
      const socket = this._healthCheck();

      if (!multicastAddress) {
        throw new ERR_MISSING_ARGS("multicastAddress");
      }

      try {
        lib.UDPSocket.dropMembership(socket, multicastAddress, interfaceAddress || undefined);
      } catch (error) {
        throw errnoException(error, "dropMembership");
      }
    }

    bind(...args) {
      let [port_, address_, callback] = args;
      let port = port_;

      if (this._bindState !== Bind.BIND_STATE_UNBOUND) throw new ERR_SOCKET_ALREADY_BOUND();

      this._bindState = Bind.BIND_STATE_BINDING;

      if (arguments.length && typeof arguments[arguments.length - 1] === "function") this.once("listening", arguments[arguments.length - 1]);

      var address;
      var exclusive;

      if (port !== null && typeof port === "object") {
        address = port.address || "";
        exclusive = !!port.exclusive;
        port = port.port;
      } else {
        address = typeof address_ === "function" ? "" : address_;
        exclusive = false;
      }

      if (!address) {
        if (this.type === "udp4") address = "0.0.0.0";else address = "::";
      }

      this.schedule(new Spawn(this, address, port));

      return this;
    }
  }

  class Spawn {
    constructor(socket, address, port) {
      this.socket = socket;
      this.address = address;
      this.port = port;
    }
    async perform() {
      const { socket, address, port } = this;
      try {
        const host = await browser.DNS.resolve(address, 0, false);
        const addressReuse = socket._reuseAddr;
        const options = port != undefined && port !== 0 ? { host, port, addressReuse } : { host, addressReuse };

        const _handle = await lib.UDPSocket.create(options);
        socket._handle = _handle;
        socket.emit("listening", this);
        listen(socket, _handle);
      } catch (error) {
        socket._bindState = Bind.BIND_STATE_UNBOUND;
        socket.emit("error", error);
      }
    }
  }
  class Send {
    constructor(socket, list, port, address, callback) {
      this.socket = socket;
      this.list = list;
      this.port = port;
      this.address = address;
      this.callback = callback;
    }
    async perform() {
      const { socket, list, port, address, callback } = this;
      const { _handle } = socket;
      const host = await browser.DNS.resolve(address, 0, false);

      if (_handle) {
        try {
          for (const { buffer } of list) {
            await lib.UDPSocket.send(_handle, host, port, buffer);
          }

          if (callback) {
            await new Promise(resolve => setTimeout(resolve, 20));
            callback(null);
          }
        } catch (error) {
          if (callback) {
            callback(error);
          }
        }
      }
    }
  }

  class Close {
    constructor(socket) {
      this.socket = socket;
    }
    async perform() {
      const { socket } = this;
      try {
        const handle = socket._healthCheck();
        socket._handle = null;
        await lib.UDPSocket.close(handle);
      } catch (error) {
        socket.emit("error", error);
      }
    }
  }

  const listen = async function (socket, handle) {
    for await (const { data, from } of lib.UDPSocket.messages(handle)) {
      socket.emit("message", _buffer.Buffer.from(data), {
        address: from.host,
        family: toNodeFamily(from.family),
        port: from.port,
        size: data.byteLength
      });
    }
    socket.emit("close");
  };

  const createSocket = (options, callback) => {
    return new Socket(options, callback);
  };

  return { createSocket, Socket };
};

function oneOf(expected, thing) {
  (0, _assert2.default)(typeof thing === "string", "`thing` has to be of type string");
  if (Array.isArray(expected)) {
    const len = expected.length;
    (0, _assert2.default)(len > 0, "At least one expected value needs to be specified");
    expected = expected.map(i => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class ERR_INVALID_ARG_TYPE extends TypeError {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.startsWith("not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }

    let msg;
    if (name.endsWith(" argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }

    msg += `. Received type ${typeof actual}`;
    super(msg);
  }
}

class ERR_MISSING_ARGS extends TypeError {
  constructor(...params) {
    let msg = "The ";
    const len = params.length;
    const args = params.map(a => `"${a}"`);
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super(`${msg} must be specified`);
  }
}

class ERR_SOCKET_ALREADY_BOUND extends Error {
  constructor() {
    super("Socket is already bound");
  }
}

class ERR_SOCKET_BAD_BUFFER_SIZE extends TypeError {
  constructor() {
    super("Buffer size must be a positive integer");
  }
}

class ERR_SOCKET_BAD_PORT extends RangeError {
  constructor(port) {
    super("Port should be > 0 and < 65536. Received ${port}.");
  }
}

class ERR_SOCKET_BAD_TYPE extends TypeError {
  constructor() {
    super("Bad socket type specified. Valid types are: udp4, udp6");
  }
}

class ERR_SOCKET_BUFFER_SIZE extends Error {
  constructor() {
    super("Could not get or set buffer size");
  }
}

class ERR_SOCKET_CANNOT_SEND extends Error {
  constructor() {
    super("Unable to send data");
  }
}

class ERR_SOCKET_DGRAM_NOT_RUNNING extends Error {
  constructor() {
    super("Not running");
  }
}

class SystemError extends Error {
  constructor(message, code, syscall) {
    super(message);
    this.code = code;
    this.syscall = syscall;
  }
  get errno() {
    return this.code;
  }
}

const errnoException = (err, syscall, original) => {
  const code = err.message;
  const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;

  const ex = new SystemError(message, code, syscall);

  return ex;
};

function sliceBuffer(source, offset, length) {
  let buffer = source;
  if (typeof buffer === "string") {
    buffer = _buffer.Buffer.from(buffer);
  } else if (!isUint8Array(buffer)) {
    throw new ERR_INVALID_ARG_TYPE("buffer", ["Buffer", "Uint8Array", "string"], buffer);
  }

  const start = offset >>> 0;
  const end = start + (length >>> 0);

  return buffer.slice(start, end);
}

function fixBufferList(list) {
  const newlist = new Array(list.length);

  for (var i = 0, l = list.length; i < l; i++) {
    var buf = list[i];
    if (typeof buf === "string") newlist[i] = _buffer.Buffer.from(buf);else if (!isUint8Array(buf)) return null;else newlist[i] = buf;
  }

  return newlist;
}

const toNodeFamily = family => family === 2 ? "udp6" : "udp4";

const fromNodeLookup = lookup => ({
  resolve: hostname => new Promise((resolve, reject) => {
    lookup(hostname, (error, address, family) => {
      if (error) {
        reject(error);
      } else {
        resolve({ addresses: [address] });
      }
    });
  })
});
module.exports = exports["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ub2RlLWRncmFtLmpzIl0sIm5hbWVzIjpbImlzVWludDhBcnJheSIsInZhbHVlIiwiVWludDhBcnJheSIsIkJpbmQiLCJCSU5EX1NUQVRFX1VOQk9VTkQiLCJCSU5EX1NUQVRFX0JJTkRJTkciLCJCSU5EX1NUQVRFX0JPVU5EIiwibGliIiwiU29ja2V0IiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwibGlzdGVuZXIiLCJvcHRpb25zIiwiZG5zIiwibG9va3VwIiwiZnJvbU5vZGVMb29rdXAiLCJfcmV1c2VBZGRyIiwicmV1c2VBZGRyIiwib24iLCJpc0lkbGUiLCJfaGFuZGxlIiwiX2JpbmRTdGF0ZSIsIndvcmtRdWV1ZSIsIl9oZWFsdGhDaGVjayIsIkVSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkciLCJzZW5kIiwiYnVmZmVyIiwiYXJncyIsIm9mZnNldCIsImxlbmd0aCIsInBvcnQiLCJhZGRyZXNzIiwiY2FsbGJhY2siLCJsaXN0Iiwic2xpY2VCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJCdWZmZXIiLCJmcm9tIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJmaXhCdWZmZXJMaXN0IiwiRVJSX1NPQ0tFVF9CQURfUE9SVCIsInVuZGVmaW5lZCIsImJpbmQiLCJleGNsdXNpdmUiLCJwdXNoIiwiYWxsb2MiLCJob3N0Iiwic2NoZWR1bGUiLCJTZW5kIiwiY2xvc2UiLCJDbG9zZSIsInRhc2siLCJhd2FrZSIsImluZGV4IiwicGVyZm9ybSIsImZhbWlseSIsInRvTm9kZUZhbWlseSIsInNldE11bHRpY2FzdExvb3BiYWNrIiwiZmxhZyIsInNvY2tldCIsIlVEUFNvY2tldCIsImVycm9yIiwiZXJybm9FeGNlcHRpb24iLCJzZXRNdWx0aWNhc3RJbnRlcmZhY2UiLCJpbnRlcmZhY2VBZGRyZXNzIiwic2V0TXVsdGljYXN0VFRMIiwidHRsIiwiYWRkTWVtYmVyc2hpcCIsIm11bHRpY2FzdEFkZHJlc3MiLCJFUlJfTUlTU0lOR19BUkdTIiwiZHJvcE1lbWJlcnNoaXAiLCJwb3J0XyIsImFkZHJlc3NfIiwiRVJSX1NPQ0tFVF9BTFJFQURZX0JPVU5EIiwiYXJndW1lbnRzIiwib25jZSIsIlNwYXduIiwiYnJvd3NlciIsIkROUyIsInJlc29sdmUiLCJhZGRyZXNzUmV1c2UiLCJjcmVhdGUiLCJlbWl0IiwibGlzdGVuIiwiUHJvbWlzZSIsInNldFRpbWVvdXQiLCJoYW5kbGUiLCJkYXRhIiwibWVzc2FnZXMiLCJzaXplIiwiYnl0ZUxlbmd0aCIsImNyZWF0ZVNvY2tldCIsIm9uZU9mIiwiZXhwZWN0ZWQiLCJ0aGluZyIsImxlbiIsIm1hcCIsImkiLCJTdHJpbmciLCJzbGljZSIsImpvaW4iLCJUeXBlRXJyb3IiLCJuYW1lIiwiYWN0dWFsIiwiZGV0ZXJtaW5lciIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwibXNnIiwiZW5kc1dpdGgiLCJpbmNsdWRlcyIsInBhcmFtcyIsImEiLCJFcnJvciIsIkVSUl9TT0NLRVRfQkFEX0JVRkZFUl9TSVpFIiwiUmFuZ2VFcnJvciIsIkVSUl9TT0NLRVRfQkFEX1RZUEUiLCJFUlJfU09DS0VUX0JVRkZFUl9TSVpFIiwiRVJSX1NPQ0tFVF9DQU5OT1RfU0VORCIsIlN5c3RlbUVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJzeXNjYWxsIiwiZXJybm8iLCJlcnIiLCJvcmlnaW5hbCIsImV4Iiwic291cmNlIiwic3RhcnQiLCJlbmQiLCJuZXdsaXN0IiwibCIsImJ1ZiIsImhvc3RuYW1lIiwicmVqZWN0IiwiYWRkcmVzc2VzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFPQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxlQUFlQyxTQUFTQSxpQkFBaUJDLFVBQS9DOztBQUVBLE1BQU1DLE9BQU87QUFDWEMsc0JBQW9CLENBRFQ7QUFFWEMsc0JBQW9CLENBRlQ7QUFHWEMsb0JBQWtCO0FBSFAsQ0FBYjs7a0JBa0VnQkMsR0FBRCxJQUFjO0FBQzNCLFFBQU1DLE1BQU4sU0FBcUJDLGdCQUFyQixDQUFrQztBQVNoQ0MsZ0JBQ0VDLElBREYsRUFFRUMsUUFGRixFQUdFO0FBQ0E7O0FBRUEsVUFBSUQsU0FBUyxJQUFULElBQWlCLE9BQU9BLElBQVAsS0FBZ0IsUUFBckMsRUFBK0M7QUFDN0MsWUFBSUUsVUFBVUYsSUFBZDtBQUNBLGFBQUtBLElBQUwsR0FBWUUsUUFBUUYsSUFBcEI7QUFDQSxhQUFLRyxHQUFMLEdBQVdELFFBQVFFLE1BQVIsR0FBaUJDLGVBQWVILFFBQVFFLE1BQXZCLENBQWpCLEdBQWtEUixJQUFJTyxHQUFqRTtBQUNBLGFBQUtHLFVBQUwsR0FBa0IsQ0FBQyxDQUFDSixRQUFRSyxTQUE1QjtBQUNELE9BTEQsTUFLTztBQUNMLGFBQUtELFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxhQUFLTixJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLRyxHQUFMLEdBQVdQLElBQUlPLEdBQWY7QUFDRDs7QUFFRCxVQUFJLE9BQU9GLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsYUFBS08sRUFBTCxDQUFRLFNBQVIsRUFBbUJQLFFBQW5CO0FBQ0Q7O0FBRUQsV0FBS1EsTUFBTCxHQUFjLElBQWQ7QUFDQSxXQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBLFdBQUtDLFVBQUwsR0FBa0JuQixLQUFLQyxrQkFBdkI7QUFDQSxXQUFLbUIsU0FBTCxHQUFpQixFQUFqQjtBQUNEO0FBQ0RDLG1CQUEwQjtBQUN4QixVQUFJLENBQUMsS0FBS0gsT0FBVixFQUFtQjtBQUVqQixjQUFNLElBQUlJLDRCQUFKLEVBQU47QUFDRDtBQUNELGFBQU8sS0FBS0osT0FBWjtBQUNEOztBQUVESyxTQUFLQyxNQUFMLEVBQXFCLEdBQUdDLElBQXhCLEVBQWlDO0FBQy9CLFVBQUksQ0FBQ0MsTUFBRCxFQUFTQyxNQUFULEVBQWlCQyxJQUFqQixFQUF1QkMsT0FBdkIsRUFBZ0NDLFFBQWhDLElBQTRDTCxJQUFoRDtBQUNBLFVBQUlNLElBQUo7O0FBRUEsVUFBSUYsV0FBWUQsUUFBUSxPQUFPQSxJQUFQLEtBQWdCLFVBQXhDLEVBQXFEO0FBQ25ESixpQkFBU1EsWUFBWVIsTUFBWixFQUFvQkUsTUFBcEIsRUFBNEJDLE1BQTVCLENBQVQ7QUFDRCxPQUZELE1BRU87QUFDTEcsbUJBQVdGLElBQVg7QUFDQUEsZUFBT0YsTUFBUDtBQUNBRyxrQkFBVUYsTUFBVjtBQUNEOztBQUVELFVBQUksQ0FBQ00sTUFBTUMsT0FBTixDQUFjVixNQUFkLENBQUwsRUFBNEI7QUFDMUIsWUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCTyxpQkFBTyxDQUFDSSxlQUFPQyxJQUFQLENBQVlaLE1BQVosQ0FBRCxDQUFQO0FBQ0QsU0FGRCxNQUVPLElBQUksQ0FBQzNCLGFBQWEyQixNQUFiLENBQUwsRUFBMkI7QUFDaEMsZ0JBQU0sSUFBSWEsb0JBQUosQ0FDSixRQURJLEVBRUosQ0FBQyxRQUFELEVBQVcsWUFBWCxFQUF5QixRQUF6QixDQUZJLEVBR0piLE1BSEksQ0FBTjtBQUtELFNBTk0sTUFNQTtBQUNMTyxpQkFBTyxDQUFDUCxNQUFELENBQVA7QUFDRDtBQUNGLE9BWkQsTUFZTyxJQUFJLEVBQUVPLE9BQU9PLGNBQWNkLE1BQWQsQ0FBVCxDQUFKLEVBQXFDO0FBQzFDLGNBQU0sSUFBSWEsb0JBQUosQ0FDSix1QkFESSxFQUVKLENBQUMsUUFBRCxFQUFXLFFBQVgsQ0FGSSxFQUdKYixNQUhJLENBQU47QUFLRDs7QUFFREksYUFBT0EsU0FBUyxDQUFoQjtBQUNBLFVBQUlBLFNBQVMsQ0FBVCxJQUFjQSxPQUFPLEtBQXpCLEVBQWdDLE1BQU0sSUFBSVcsbUJBQUosQ0FBd0JYLElBQXhCLENBQU47O0FBSWhDLFVBQUksT0FBT0UsUUFBUCxLQUFvQixVQUF4QixFQUFvQ0EsV0FBV1UsU0FBWDs7QUFFcEMsVUFBSSxPQUFPWCxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDQyxtQkFBV0QsT0FBWDtBQUNBQSxrQkFBVVcsU0FBVjtBQUNELE9BSEQsTUFHTyxJQUFJWCxXQUFXLE9BQU9BLE9BQVAsS0FBbUIsUUFBbEMsRUFBNEM7QUFDakQsY0FBTSxJQUFJUSxvQkFBSixDQUF5QixTQUF6QixFQUFvQyxDQUFDLFFBQUQsRUFBVyxPQUFYLENBQXBDLEVBQXlEUixPQUF6RCxDQUFOO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLVixVQUFMLEtBQW9CbkIsS0FBS0Msa0JBQTdCLEVBQWlEO0FBQy9DLGFBQUt3QyxJQUFMLENBQVUsRUFBRWIsTUFBTSxDQUFSLEVBQVdjLFdBQVcsSUFBdEIsRUFBVixFQUF3QyxJQUF4QztBQUNEOztBQUVELFVBQUlYLEtBQUtKLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckJJLGFBQUtZLElBQUwsQ0FBVVIsZUFBT1MsS0FBUCxDQUFhLENBQWIsQ0FBVjtBQUNEOztBQUVELFlBQU1DLE9BQU9oQixZQUFZLEtBQUtyQixJQUFMLEtBQWMsTUFBZCxHQUF1QixXQUF2QixHQUFxQyxLQUFqRCxDQUFiO0FBQ0EsV0FBS3NDLFFBQUwsQ0FBYyxJQUFJQyxJQUFKLENBQVMsSUFBVCxFQUFlaEIsSUFBZixFQUFxQkgsSUFBckIsRUFBMkJpQixJQUEzQixFQUFpQ2YsUUFBakMsQ0FBZDtBQUNEOztBQUVEa0IsVUFBTWxCLFFBQU4sRUFBZ0M7QUFDOUIsVUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDLGFBQUtkLEVBQUwsQ0FBUSxPQUFSLEVBQWlCYyxRQUFqQjtBQUNEOztBQUVELFdBQUtnQixRQUFMLENBQWMsSUFBSUcsS0FBSixDQUFVLElBQVYsQ0FBZDtBQUNEOztBQUVESCxhQUFTSSxJQUFULEVBQXFCO0FBQ25CLFdBQUs5QixTQUFMLENBQWV1QixJQUFmLENBQW9CTyxJQUFwQjtBQUNBLFVBQUksS0FBS2pDLE1BQVQsRUFBaUI7QUFDZixhQUFLa0MsS0FBTDtBQUNEO0FBQ0Y7QUFDRCxVQUFNQSxLQUFOLEdBQWM7QUFDWixVQUFJLEtBQUtsQyxNQUFULEVBQWlCO0FBQ2YsYUFBS0EsTUFBTCxHQUFjLEtBQWQ7QUFDQSxjQUFNLEVBQUVHLFNBQUYsS0FBZ0IsSUFBdEI7QUFDQSxZQUFJZ0MsUUFBUSxDQUFaO0FBQ0EsZUFBT0EsUUFBUWhDLFVBQVVPLE1BQXpCLEVBQWlDO0FBQy9CLGdCQUFNdUIsT0FBTzlCLFVBQVVnQyxPQUFWLENBQWI7QUFDQSxnQkFBTUYsS0FBS0csT0FBTCxFQUFOO0FBQ0Q7QUFDRGpDLGtCQUFVTyxNQUFWLEdBQW1CLENBQW5CO0FBQ0EsYUFBS1YsTUFBTCxHQUFjLElBQWQ7QUFDRDtBQUNGOztBQUVEWSxjQUFVO0FBQ1IsWUFBTSxFQUFFZ0IsSUFBRixFQUFRakIsSUFBUixFQUFjMEIsTUFBZCxLQUF5QixLQUFLakMsWUFBTCxHQUFvQlEsT0FBbkQ7QUFDQSxhQUFPO0FBQ0xBLGlCQUFTZ0IsSUFESjtBQUVMQSxZQUZLO0FBR0xqQixZQUhLO0FBSUwwQixnQkFBUUMsYUFBYUQsTUFBYjtBQUpILE9BQVA7QUFNRDs7QUFFREUseUJBQXFCQyxJQUFyQixFQUFvQztBQUNsQyxZQUFNQyxTQUFTLEtBQUtyQyxZQUFMLEVBQWY7O0FBRUEsVUFBSTtBQUNGakIsWUFBSXVELFNBQUosQ0FBY0gsb0JBQWQsQ0FBbUNFLE1BQW5DLEVBQTJDRCxJQUEzQztBQUNELE9BRkQsQ0FFRSxPQUFPRyxLQUFQLEVBQWM7QUFDZCxjQUFNQyxlQUFlRCxLQUFmLEVBQXNCLHNCQUF0QixDQUFOO0FBQ0Q7QUFDRjs7QUFFREUsMEJBQXNCQyxnQkFBdEIsRUFBZ0Q7QUFDOUMsWUFBTUwsU0FBUyxLQUFLckMsWUFBTCxFQUFmOztBQUVBLFVBQUksT0FBTzBDLGdCQUFQLEtBQTRCLFFBQWhDLEVBQTBDO0FBQ3hDLGNBQU0sSUFBSTFCLG9CQUFKLENBQ0osa0JBREksRUFFSixRQUZJLEVBR0owQixnQkFISSxDQUFOO0FBS0Q7O0FBRUQsVUFBSTtBQUNGM0QsWUFBSXVELFNBQUosQ0FBY0cscUJBQWQsQ0FBb0NKLE1BQXBDLEVBQTRDSyxnQkFBNUM7QUFDRCxPQUZELENBRUUsT0FBT0gsS0FBUCxFQUFjO0FBQ2QsY0FBTUMsZUFBZUQsS0FBZixFQUFzQix1QkFBdEIsQ0FBTjtBQUNEO0FBQ0Y7O0FBRURJLG9CQUFnQkMsR0FBaEIsRUFBNkIsQ0FFNUI7O0FBRURDLGtCQUFjQyxnQkFBZCxFQUF3Q0osZ0JBQXhDLEVBQW1FO0FBQ2pFLFlBQU1MLFNBQVMsS0FBS3JDLFlBQUwsRUFBZjs7QUFFQSxVQUFJLENBQUM4QyxnQkFBTCxFQUF1QjtBQUNyQixjQUFNLElBQUlDLGdCQUFKLENBQXFCLGtCQUFyQixDQUFOO0FBQ0Q7O0FBRUQsVUFBSTtBQUNGaEUsWUFBSXVELFNBQUosQ0FBY08sYUFBZCxDQUE0QlIsTUFBNUIsRUFBb0NTLGdCQUFwQyxFQUFzREosZ0JBQXREO0FBQ0QsT0FGRCxDQUVFLE9BQU9ILEtBQVAsRUFBYztBQUNkLGNBQU1DLGVBQWVELEtBQWYsRUFBc0IsZUFBdEIsQ0FBTjtBQUNEO0FBQ0Y7QUFDRFMsbUJBQWVGLGdCQUFmLEVBQXlDSixnQkFBekMsRUFBb0U7QUFDbEUsWUFBTUwsU0FBUyxLQUFLckMsWUFBTCxFQUFmOztBQUVBLFVBQUksQ0FBQzhDLGdCQUFMLEVBQXVCO0FBQ3JCLGNBQU0sSUFBSUMsZ0JBQUosQ0FBcUIsa0JBQXJCLENBQU47QUFDRDs7QUFFRCxVQUFJO0FBQ0ZoRSxZQUFJdUQsU0FBSixDQUFjVSxjQUFkLENBQ0VYLE1BREYsRUFFRVMsZ0JBRkYsRUFHRUosb0JBQW9CdkIsU0FIdEI7QUFLRCxPQU5ELENBTUUsT0FBT29CLEtBQVAsRUFBYztBQUNkLGNBQU1DLGVBQWVELEtBQWYsRUFBc0IsZ0JBQXRCLENBQU47QUFDRDtBQUNGOztBQUVEbkIsU0FBSyxHQUFHaEIsSUFBUixFQUFpQjtBQUNmLFVBQUksQ0FBQzZDLEtBQUQsRUFBUUMsUUFBUixFQUFrQnpDLFFBQWxCLElBQThCTCxJQUFsQztBQUNBLFVBQUlHLE9BQU8wQyxLQUFYOztBQUVBLFVBQUksS0FBS25ELFVBQUwsS0FBb0JuQixLQUFLQyxrQkFBN0IsRUFDRSxNQUFNLElBQUl1RSx3QkFBSixFQUFOOztBQUVGLFdBQUtyRCxVQUFMLEdBQWtCbkIsS0FBS0Usa0JBQXZCOztBQUVBLFVBQ0V1RSxVQUFVOUMsTUFBVixJQUNBLE9BQU84QyxVQUFVQSxVQUFVOUMsTUFBVixHQUFtQixDQUE3QixDQUFQLEtBQTJDLFVBRjdDLEVBSUUsS0FBSytDLElBQUwsQ0FBVSxXQUFWLEVBQXVCRCxVQUFVQSxVQUFVOUMsTUFBVixHQUFtQixDQUE3QixDQUF2Qjs7QUFFRixVQUFJRSxPQUFKO0FBQ0EsVUFBSWEsU0FBSjs7QUFFQSxVQUFJZCxTQUFTLElBQVQsSUFBaUIsT0FBT0EsSUFBUCxLQUFnQixRQUFyQyxFQUErQztBQUM3Q0Msa0JBQVVELEtBQUtDLE9BQUwsSUFBZ0IsRUFBMUI7QUFDQWEsb0JBQVksQ0FBQyxDQUFDZCxLQUFLYyxTQUFuQjtBQUNBZCxlQUFPQSxLQUFLQSxJQUFaO0FBQ0QsT0FKRCxNQUlPO0FBQ0xDLGtCQUFVLE9BQU8wQyxRQUFQLEtBQW9CLFVBQXBCLEdBQWlDLEVBQWpDLEdBQXNDQSxRQUFoRDtBQUNBN0Isb0JBQVksS0FBWjtBQUNEOztBQUdELFVBQUksQ0FBQ2IsT0FBTCxFQUFjO0FBQ1osWUFBSSxLQUFLckIsSUFBTCxLQUFjLE1BQWxCLEVBQTBCcUIsVUFBVSxTQUFWLENBQTFCLEtBQ0tBLFVBQVUsSUFBVjtBQUNOOztBQUVELFdBQUtpQixRQUFMLENBQWMsSUFBSTZCLEtBQUosQ0FBVSxJQUFWLEVBQWdCOUMsT0FBaEIsRUFBeUJELElBQXpCLENBQWQ7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7QUE5TytCOztBQWlQbEMsUUFBTStDLEtBQU4sQ0FBWTtBQUlWcEUsZ0JBQVltRCxNQUFaLEVBQTRCN0IsT0FBNUIsRUFBNkNELElBQTdDLEVBQTJEO0FBQ3pELFdBQUs4QixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxXQUFLN0IsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsV0FBS0QsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7QUFDRCxVQUFNeUIsT0FBTixHQUFnQjtBQUNkLFlBQU0sRUFBRUssTUFBRixFQUFVN0IsT0FBVixFQUFtQkQsSUFBbkIsS0FBNEIsSUFBbEM7QUFDQSxVQUFJO0FBQ0YsY0FBTWlCLE9BQU8sTUFBTStCLFFBQVFDLEdBQVIsQ0FBWUMsT0FBWixDQUFvQmpELE9BQXBCLEVBQTZCLENBQTdCLEVBQWdDLEtBQWhDLENBQW5CO0FBQ0EsY0FBTWtELGVBQWVyQixPQUFPNUMsVUFBNUI7QUFDQSxjQUFNSixVQUNKa0IsUUFBUVksU0FBUixJQUFxQlosU0FBUyxDQUE5QixHQUNJLEVBQUVpQixJQUFGLEVBQVFqQixJQUFSLEVBQWNtRCxZQUFkLEVBREosR0FFSSxFQUFFbEMsSUFBRixFQUFRa0MsWUFBUixFQUhOOztBQUtBLGNBQU03RCxVQUFVLE1BQU1kLElBQUl1RCxTQUFKLENBQWNxQixNQUFkLENBQXFCdEUsT0FBckIsQ0FBdEI7QUFDQWdELGVBQU94QyxPQUFQLEdBQWlCQSxPQUFqQjtBQUNBd0MsZUFBT3VCLElBQVAsQ0FBWSxXQUFaLEVBQXlCLElBQXpCO0FBQ0FDLGVBQU94QixNQUFQLEVBQWV4QyxPQUFmO0FBQ0QsT0FaRCxDQVlFLE9BQU8wQyxLQUFQLEVBQWM7QUFDZEYsZUFBT3ZDLFVBQVAsR0FBb0JuQixLQUFLQyxrQkFBekI7QUFDQXlELGVBQU91QixJQUFQLENBQVksT0FBWixFQUFxQnJCLEtBQXJCO0FBQ0Q7QUFDRjtBQTNCUztBQTZCWixRQUFNYixJQUFOLENBQVc7QUFNVHhDLGdCQUFZbUQsTUFBWixFQUE0QjNCLElBQTVCLEVBQWtDSCxJQUFsQyxFQUFnREMsT0FBaEQsRUFBaUVDLFFBQWpFLEVBQTJFO0FBQ3pFLFdBQUs0QixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxXQUFLM0IsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsV0FBS0gsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsV0FBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsV0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDRDtBQUNELFVBQU11QixPQUFOLEdBQWdCO0FBQ2QsWUFBTSxFQUFFSyxNQUFGLEVBQVUzQixJQUFWLEVBQWdCSCxJQUFoQixFQUFzQkMsT0FBdEIsRUFBK0JDLFFBQS9CLEtBQTRDLElBQWxEO0FBQ0EsWUFBTSxFQUFFWixPQUFGLEtBQWN3QyxNQUFwQjtBQUNBLFlBQU1iLE9BQU8sTUFBTStCLFFBQVFDLEdBQVIsQ0FBWUMsT0FBWixDQUFvQmpELE9BQXBCLEVBQTZCLENBQTdCLEVBQWdDLEtBQWhDLENBQW5COztBQUVBLFVBQUlYLE9BQUosRUFBYTtBQUNYLFlBQUk7QUFDRixlQUFLLE1BQU0sRUFBRU0sTUFBRixFQUFYLElBQXlCTyxJQUF6QixFQUErQjtBQUM3QixrQkFBTTNCLElBQUl1RCxTQUFKLENBQWNwQyxJQUFkLENBQW1CTCxPQUFuQixFQUE0QjJCLElBQTVCLEVBQWtDakIsSUFBbEMsRUFBd0NKLE1BQXhDLENBQU47QUFDRDs7QUFLRCxjQUFJTSxRQUFKLEVBQWM7QUFDWixrQkFBTSxJQUFJcUQsT0FBSixDQUFZTCxXQUFXTSxXQUFXTixPQUFYLEVBQW9CLEVBQXBCLENBQXZCLENBQU47QUFDQWhELHFCQUFTLElBQVQ7QUFDRDtBQUNGLFNBWkQsQ0FZRSxPQUFPOEIsS0FBUCxFQUFjO0FBQ2QsY0FBSTlCLFFBQUosRUFBYztBQUNaQSxxQkFBUzhCLEtBQVQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQXJDUTs7QUF3Q1gsUUFBTVgsS0FBTixDQUFZO0FBRVYxQyxnQkFBWW1ELE1BQVosRUFBb0I7QUFDbEIsV0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7QUFDRCxVQUFNTCxPQUFOLEdBQWdCO0FBQ2QsWUFBTSxFQUFFSyxNQUFGLEtBQWEsSUFBbkI7QUFDQSxVQUFJO0FBQ0YsY0FBTTJCLFNBQVMzQixPQUFPckMsWUFBUCxFQUFmO0FBQ0FxQyxlQUFPeEMsT0FBUCxHQUFpQixJQUFqQjtBQUNBLGNBQU1kLElBQUl1RCxTQUFKLENBQWNYLEtBQWQsQ0FBb0JxQyxNQUFwQixDQUFOO0FBRUQsT0FMRCxDQUtFLE9BQU96QixLQUFQLEVBQWM7QUFDZEYsZUFBT3VCLElBQVAsQ0FBWSxPQUFaLEVBQXFCckIsS0FBckI7QUFDRDtBQUNGO0FBZlM7O0FBa0JaLFFBQU1zQixTQUFTLGdCQUFleEIsTUFBZixFQUF1QjJCLE1BQXZCLEVBQStCO0FBQzVDLGVBQVcsTUFBTSxFQUFFQyxJQUFGLEVBQVFsRCxJQUFSLEVBQWpCLElBQW1DaEMsSUFBSXVELFNBQUosQ0FBYzRCLFFBQWQsQ0FBdUJGLE1BQXZCLENBQW5DLEVBQW1FO0FBQ2pFM0IsYUFBT3VCLElBQVAsQ0FBWSxTQUFaLEVBQXVCOUMsZUFBT0MsSUFBUCxDQUFZa0QsSUFBWixDQUF2QixFQUEwQztBQUN4Q3pELGlCQUFTTyxLQUFLUyxJQUQwQjtBQUV4Q1MsZ0JBQVFDLGFBQWFuQixLQUFLa0IsTUFBbEIsQ0FGZ0M7QUFHeEMxQixjQUFNUSxLQUFLUixJQUg2QjtBQUl4QzRELGNBQU1GLEtBQUtHO0FBSjZCLE9BQTFDO0FBTUQ7QUFDRC9CLFdBQU91QixJQUFQLENBQVksT0FBWjtBQUNELEdBVkQ7O0FBWUEsUUFBTVMsZUFBZSxDQUNuQmhGLE9BRG1CLEVBRW5Cb0IsUUFGbUIsS0FHaEI7QUFDSCxXQUFPLElBQUl6QixNQUFKLENBQVdLLE9BQVgsRUFBb0JvQixRQUFwQixDQUFQO0FBQ0QsR0FMRDs7QUFPQSxTQUFPLEVBQUU0RCxZQUFGLEVBQWdCckYsTUFBaEIsRUFBUDtBQUNELEM7O0FBRUQsU0FBU3NGLEtBQVQsQ0FBZUMsUUFBZixFQUF5QkMsS0FBekIsRUFBZ0M7QUFDOUIsd0JBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QixFQUFrQyxrQ0FBbEM7QUFDQSxNQUFJNUQsTUFBTUMsT0FBTixDQUFjMEQsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFVBQU1FLE1BQU1GLFNBQVNqRSxNQUFyQjtBQUNBLDBCQUFPbUUsTUFBTSxDQUFiLEVBQWdCLG1EQUFoQjtBQUNBRixlQUFXQSxTQUFTRyxHQUFULENBQWFDLEtBQUtDLE9BQU9ELENBQVAsQ0FBbEIsQ0FBWDtBQUNBLFFBQUlGLE1BQU0sQ0FBVixFQUFhO0FBQ1gsYUFDRyxVQUFTRCxLQUFNLElBQUdELFNBQVNNLEtBQVQsQ0FBZSxDQUFmLEVBQWtCSixNQUFNLENBQXhCLEVBQTJCSyxJQUEzQixDQUFnQyxJQUFoQyxDQUFzQyxPQUF6RCxHQUNBUCxTQUFTRSxNQUFNLENBQWYsQ0FGRjtBQUlELEtBTEQsTUFLTyxJQUFJQSxRQUFRLENBQVosRUFBZTtBQUNwQixhQUFRLFVBQVNELEtBQU0sSUFBR0QsU0FBUyxDQUFULENBQVksT0FBTUEsU0FBUyxDQUFULENBQVksRUFBeEQ7QUFDRCxLQUZNLE1BRUE7QUFDTCxhQUFRLE1BQUtDLEtBQU0sSUFBR0QsU0FBUyxDQUFULENBQVksRUFBbEM7QUFDRDtBQUNGLEdBZEQsTUFjTztBQUNMLFdBQVEsTUFBS0MsS0FBTSxJQUFHSSxPQUFPTCxRQUFQLENBQWlCLEVBQXZDO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNdkQsb0JBQU4sU0FBbUMrRCxTQUFuQyxDQUE2QztBQUMzQzdGLGNBQVk4RixJQUFaLEVBQWtCVCxRQUFsQixFQUE0QlUsTUFBNUIsRUFBb0M7QUFFbEMsUUFBSUMsVUFBSjtBQUNBLFFBQUksT0FBT1gsUUFBUCxLQUFvQixRQUFwQixJQUFnQ0EsU0FBU1ksVUFBVCxDQUFvQixNQUFwQixDQUFwQyxFQUFpRTtBQUMvREQsbUJBQWEsYUFBYjtBQUNBWCxpQkFBV0EsU0FBU2EsT0FBVCxDQUFpQixPQUFqQixFQUEwQixFQUExQixDQUFYO0FBQ0QsS0FIRCxNQUdPO0FBQ0xGLG1CQUFhLFNBQWI7QUFDRDs7QUFFRCxRQUFJRyxHQUFKO0FBQ0EsUUFBSUwsS0FBS00sUUFBTCxDQUFjLFdBQWQsQ0FBSixFQUFnQztBQUU5QkQsWUFBTyxPQUFNTCxJQUFLLElBQUdFLFVBQVcsSUFBR1osTUFBTUMsUUFBTixFQUFnQixNQUFoQixDQUF3QixFQUEzRDtBQUNELEtBSEQsTUFHTztBQUNMLFlBQU1wRixPQUFPNkYsS0FBS08sUUFBTCxDQUFjLEdBQWQsSUFBcUIsVUFBckIsR0FBa0MsVUFBL0M7QUFDQUYsWUFBTyxRQUFPTCxJQUFLLEtBQUk3RixJQUFLLElBQUcrRixVQUFXLElBQUdaLE1BQU1DLFFBQU4sRUFBZ0IsTUFBaEIsQ0FBd0IsRUFBckU7QUFDRDs7QUFHRGMsV0FBUSxtQkFBa0IsT0FBT0osTUFBTyxFQUF4QztBQUNBLFVBQU1JLEdBQU47QUFDRDtBQXZCMEM7O0FBMEI3QyxNQUFNdEMsZ0JBQU4sU0FBK0JnQyxTQUEvQixDQUF5QztBQUN2QzdGLGNBQVksR0FBR3NHLE1BQWYsRUFBdUI7QUFDckIsUUFBSUgsTUFBTSxNQUFWO0FBQ0EsVUFBTVosTUFBTWUsT0FBT2xGLE1BQW5CO0FBQ0EsVUFBTUYsT0FBT29GLE9BQU9kLEdBQVAsQ0FBV2UsS0FBTSxJQUFHQSxDQUFFLEdBQXRCLENBQWI7QUFDQSxZQUFRaEIsR0FBUjtBQUNFLFdBQUssQ0FBTDtBQUNFWSxlQUFRLEdBQUVqRixLQUFLLENBQUwsQ0FBUSxXQUFsQjtBQUNBO0FBQ0YsV0FBSyxDQUFMO0FBQ0VpRixlQUFRLEdBQUVqRixLQUFLLENBQUwsQ0FBUSxRQUFPQSxLQUFLLENBQUwsQ0FBUSxZQUFqQztBQUNBO0FBQ0Y7QUFDRWlGLGVBQU9qRixLQUFLeUUsS0FBTCxDQUFXLENBQVgsRUFBY0osTUFBTSxDQUFwQixFQUF1QkssSUFBdkIsQ0FBNEIsSUFBNUIsQ0FBUDtBQUNBTyxlQUFRLFNBQVFqRixLQUFLcUUsTUFBTSxDQUFYLENBQWMsWUFBOUI7QUFDQTtBQVZKO0FBWUEsVUFBTyxHQUFFWSxHQUFJLG9CQUFiO0FBQ0Q7QUFsQnNDOztBQXFCekMsTUFBTWxDLHdCQUFOLFNBQXVDdUMsS0FBdkMsQ0FBNkM7QUFDM0N4RyxnQkFBYztBQUNaLFVBQU0seUJBQU47QUFDRDtBQUgwQzs7QUFNN0MsTUFBTXlHLDBCQUFOLFNBQXlDWixTQUF6QyxDQUFtRDtBQUNqRDdGLGdCQUFjO0FBQ1osVUFBTSx3Q0FBTjtBQUNEO0FBSGdEOztBQU1uRCxNQUFNZ0MsbUJBQU4sU0FBa0MwRSxVQUFsQyxDQUE2QztBQUMzQzFHLGNBQVlxQixJQUFaLEVBQWtCO0FBQ2hCLFVBQU0sbURBQU47QUFDRDtBQUgwQzs7QUFNN0MsTUFBTXNGLG1CQUFOLFNBQWtDZCxTQUFsQyxDQUE0QztBQUMxQzdGLGdCQUFjO0FBQ1osVUFBTSx3REFBTjtBQUNEO0FBSHlDOztBQU01QyxNQUFNNEcsc0JBQU4sU0FBcUNKLEtBQXJDLENBQTJDO0FBQ3pDeEcsZ0JBQWM7QUFDWixVQUFNLGtDQUFOO0FBQ0Q7QUFId0M7O0FBTTNDLE1BQU02RyxzQkFBTixTQUFxQ0wsS0FBckMsQ0FBMkM7QUFDekN4RyxnQkFBYztBQUNaLFVBQU0scUJBQU47QUFDRDtBQUh3Qzs7QUFNM0MsTUFBTWUsNEJBQU4sU0FBMkN5RixLQUEzQyxDQUFpRDtBQUMvQ3hHLGdCQUFjO0FBQ1osVUFBTSxhQUFOO0FBQ0Q7QUFIOEM7O0FBTWpELE1BQU04RyxXQUFOLFNBQTBCTixLQUExQixDQUFnQztBQUc5QnhHLGNBQVkrRyxPQUFaLEVBQXFCQyxJQUFyQixFQUEyQkMsT0FBM0IsRUFBb0M7QUFDbEMsVUFBTUYsT0FBTjtBQUNBLFNBQUtDLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNEO0FBQ0QsTUFBSUMsS0FBSixHQUFZO0FBQ1YsV0FBTyxLQUFLRixJQUFaO0FBQ0Q7QUFWNkI7O0FBYWhDLE1BQU0xRCxpQkFBaUIsQ0FBQzZELEdBQUQsRUFBTUYsT0FBTixFQUFlRyxRQUFmLEtBQTRCO0FBQ2pELFFBQU1KLE9BQU9HLElBQUlKLE9BQWpCO0FBQ0EsUUFBTUEsVUFBVUssV0FDWCxHQUFFSCxPQUFRLElBQUdELElBQUssSUFBR0ksUUFBUyxFQURuQixHQUVYLEdBQUVILE9BQVEsSUFBR0QsSUFBSyxFQUZ2Qjs7QUFLQSxRQUFNSyxLQUFLLElBQUlQLFdBQUosQ0FBZ0JDLE9BQWhCLEVBQXlCQyxJQUF6QixFQUErQkMsT0FBL0IsQ0FBWDs7QUFFQSxTQUFPSSxFQUFQO0FBQ0QsQ0FWRDs7QUFZQSxTQUFTNUYsV0FBVCxDQUFxQjZGLE1BQXJCLEVBQTZCbkcsTUFBN0IsRUFBcUNDLE1BQXJDLEVBQTZDO0FBQzNDLE1BQUlILFNBQVNxRyxNQUFiO0FBQ0EsTUFBSSxPQUFPckcsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QkEsYUFBU1csZUFBT0MsSUFBUCxDQUFZWixNQUFaLENBQVQ7QUFDRCxHQUZELE1BRU8sSUFBSSxDQUFDM0IsYUFBYTJCLE1BQWIsQ0FBTCxFQUEyQjtBQUNoQyxVQUFNLElBQUlhLG9CQUFKLENBQ0osUUFESSxFQUVKLENBQUMsUUFBRCxFQUFXLFlBQVgsRUFBeUIsUUFBekIsQ0FGSSxFQUdKYixNQUhJLENBQU47QUFLRDs7QUFFRCxRQUFNc0csUUFBUXBHLFdBQVcsQ0FBekI7QUFDQSxRQUFNcUcsTUFBTUQsU0FBU25HLFdBQVcsQ0FBcEIsQ0FBWjs7QUFFQSxTQUFPSCxPQUFPMEUsS0FBUCxDQUFhNEIsS0FBYixFQUFvQkMsR0FBcEIsQ0FBUDtBQUNEOztBQUVELFNBQVN6RixhQUFULENBQXVCUCxJQUF2QixFQUE2QjtBQUMzQixRQUFNaUcsVUFBVSxJQUFJL0YsS0FBSixDQUFVRixLQUFLSixNQUFmLENBQWhCOztBQUVBLE9BQUssSUFBSXFFLElBQUksQ0FBUixFQUFXaUMsSUFBSWxHLEtBQUtKLE1BQXpCLEVBQWlDcUUsSUFBSWlDLENBQXJDLEVBQXdDakMsR0FBeEMsRUFBNkM7QUFDM0MsUUFBSWtDLE1BQU1uRyxLQUFLaUUsQ0FBTCxDQUFWO0FBQ0EsUUFBSSxPQUFPa0MsR0FBUCxLQUFlLFFBQW5CLEVBQTZCRixRQUFRaEMsQ0FBUixJQUFhN0QsZUFBT0MsSUFBUCxDQUFZOEYsR0FBWixDQUFiLENBQTdCLEtBQ0ssSUFBSSxDQUFDckksYUFBYXFJLEdBQWIsQ0FBTCxFQUF3QixPQUFPLElBQVAsQ0FBeEIsS0FDQUYsUUFBUWhDLENBQVIsSUFBYWtDLEdBQWI7QUFDTjs7QUFFRCxTQUFPRixPQUFQO0FBQ0Q7O0FBRUQsTUFBTXpFLGVBQWVELFVBQVdBLFdBQVcsQ0FBWCxHQUFlLE1BQWYsR0FBd0IsTUFBeEQ7O0FBVUEsTUFBTXpDLGlCQUFrQkQsTUFBRCxLQUFxQjtBQUMxQ2tFLFdBQVVxRCxRQUFELElBQ1AsSUFBSWhELE9BQUosQ0FBWSxDQUFDTCxPQUFELEVBQVVzRCxNQUFWLEtBQXFCO0FBQy9CeEgsV0FBT3VILFFBQVAsRUFBaUIsQ0FBQ3ZFLEtBQUQsRUFBUS9CLE9BQVIsRUFBaUJ5QixNQUFqQixLQUE0QjtBQUMzQyxVQUFJTSxLQUFKLEVBQVc7QUFDVHdFLGVBQU94RSxLQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xrQixnQkFBUSxFQUFFdUQsV0FBVyxDQUFDeEcsT0FBRCxDQUFiLEVBQVI7QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJEO0FBRndDLENBQXJCLENBQXZCIiwiZmlsZSI6Im5vZGUtZGdyYW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHR5cGUge1xyXG4gIFVEUFNvY2tldE1hbmFnZXIsXHJcbiAgVURQU29ja2V0LFxyXG4gIFNvY2tldE9wdGlvbnNcclxufSBmcm9tIFwibGliZHdlYi9zcmMvVURQU29ja2V0L1VEUFNvY2tldFwiXHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50c1wiXHJcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIlxyXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIlxyXG5cclxuY29uc3QgaXNVaW50OEFycmF5ID0gdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5XHJcblxyXG5jb25zdCBCaW5kID0ge1xyXG4gIEJJTkRfU1RBVEVfVU5CT1VORDogMCxcclxuICBCSU5EX1NUQVRFX0JJTkRJTkc6IDEsXHJcbiAgQklORF9TVEFURV9CT1VORDogMlxyXG59XHJcblxyXG50eXBlIEJpbmRTdGF0ZSA9ICRWYWx1ZXM8dHlwZW9mIEJpbmQ+XHJcblxyXG4vLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvZG5zL3Jlc29sdmVcclxuXHJcbmludGVyZmFjZSBETlMge1xyXG4gIHJlc29sdmUoaG9zdG5hbWU6IHN0cmluZywgZmxhZ3M/OiBETlNSZXNvbHZlRmxhZ1tdKTogUHJvbWlzZTxETlNSZWNvcmQ+O1xyXG59XHJcblxyXG50eXBlIEROU1Jlc29sdmVGbGFnID1cclxuICB8IFwiYWxsb3dfbmFtZV9jb2xsaXNpb25zXCJcclxuICB8IFwiYnlwYXNzX2NhY2hlXCJcclxuICB8IFwiY2Fub25pY2FsX25hbWVcIlxyXG4gIHwgXCJkaXNhYmxlX2lwdjRcIlxyXG4gIHwgXCJkaXNhYmxlX2lwdjZcIlxyXG4gIHwgXCJkaXNhYmxlX3RyclwiXHJcbiAgfCBcIm9mZmxpbmVcIlxyXG4gIHwgXCJwcmlvcml0eV9sb3dcIlxyXG4gIHwgXCJwcmlvcml0eV9tZWRpdW1cIlxyXG4gIHwgXCJzcGVjdWxhdGVcIlxyXG5cclxuaW50ZXJmYWNlIEROU1JlY29yZCB7XHJcbiAgYWRkcmVzc2VzOiBzdHJpbmdbXTtcclxuICBjYW5vbmljYWxOYW1lPzogc3RyaW5nO1xyXG4gIGlzVFJSOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTGliIHtcclxuICBVRFBTb2NrZXQ6IFVEUFNvY2tldE1hbmFnZXI7XHJcbiAgZG5zOiBETlM7XHJcbn1cclxuXHJcbmludGVyZmFjZSBOb2RlU29ja2V0T3B0aW9ucyB7XHJcbiAgdHlwZTogU29ja2V0VHlwZTtcclxuICByZXVzZUFkZHI/OiBib29sZWFuO1xyXG4gIHJlY3ZCdWZmZXJTaXplPzogbnVtYmVyO1xyXG4gIHNlbmRCdWZmZXJTaXplPzogbnVtYmVyO1xyXG4gIGxvb2t1cD86IChob3N0bmFtZTogc3RyaW5nLCAoZXJyb3I6ID9FcnJvciwgc3RyaW5nLCBzdHJpbmcpID0+IHZvaWQpID0+IHZvaWQ7XHJcbn1cclxuXHJcbnR5cGUgU29ja2V0VHlwZSA9IFwidWRwNFwiIHwgXCJ1ZHA2XCJcclxuXHJcbmludGVyZmFjZSBUYXNrIHtcclxuICBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmludGVyZmFjZSBNZXNzYWdlTGlzdGVuZXIge1xyXG4gIChcclxuICAgIG1zZzogQnVmZmVyLFxyXG4gICAgcmluZm86IHsgYWRkcmVzczogc3RyaW5nLCBmYW1pbHk6IHN0cmluZywgcG9ydDogbnVtYmVyLCBzaXplOiBudW1iZXIgfVxyXG4gICk6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBCaW5kTGlzdGVuZXIge1xyXG4gICgpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2xvc2VMaXN0ZW5lciB7XHJcbiAgKCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IChsaWI6IExpYikgPT4ge1xyXG4gIGNsYXNzIFNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBfaGFuZGxlOiA/VURQU29ja2V0XHJcbiAgICBpc0lkbGU6IGJvb2xlYW5cclxuICAgIF9iaW5kU3RhdGU6IEJpbmRTdGF0ZVxyXG4gICAgX3JldXNlQWRkcjogYm9vbGVhblxyXG4gICAgZG5zOiB7IHJlc29sdmUoc3RyaW5nKTogUHJvbWlzZTx7IGFkZHJlc3Nlczogc3RyaW5nW10gfT4gfVxyXG4gICAgd29ya1F1ZXVlOiBUYXNrW11cclxuICAgIHR5cGU6IFNvY2tldFR5cGVcclxuICAgIGxpc3RlbmVyOiA/TWVzc2FnZUxpc3RlbmVyXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgdHlwZTogU29ja2V0VHlwZSB8IE5vZGVTb2NrZXRPcHRpb25zLFxyXG4gICAgICBsaXN0ZW5lcjogTWVzc2FnZUxpc3RlbmVyXHJcbiAgICApIHtcclxuICAgICAgc3VwZXIoKVxyXG5cclxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVcclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGVcclxuICAgICAgICB0aGlzLmRucyA9IG9wdGlvbnMubG9va3VwID8gZnJvbU5vZGVMb29rdXAob3B0aW9ucy5sb29rdXApIDogbGliLmRuc1xyXG4gICAgICAgIHRoaXMuX3JldXNlQWRkciA9ICEhb3B0aW9ucy5yZXVzZUFkZHJcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9yZXVzZUFkZHIgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGVcclxuICAgICAgICB0aGlzLmRucyA9IGxpYi5kbnNcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgdGhpcy5vbihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuaXNJZGxlID0gdHJ1ZVxyXG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsXHJcbiAgICAgIHRoaXMuX2JpbmRTdGF0ZSA9IEJpbmQuQklORF9TVEFURV9VTkJPVU5EXHJcbiAgICAgIHRoaXMud29ya1F1ZXVlID0gW11cclxuICAgIH1cclxuICAgIF9oZWFsdGhDaGVjaygpOiBVRFBTb2NrZXQge1xyXG4gICAgICBpZiAoIXRoaXMuX2hhbmRsZSkge1xyXG4gICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZnJvbSBkZ3JhbV9sZWdhY3kuanMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkcoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVcclxuICAgIH1cclxuXHJcbiAgICBzZW5kKGJ1ZmZlcjogQnVmZmVyLCAuLi5hcmdzOiAqKSB7XHJcbiAgICAgIGxldCBbb2Zmc2V0LCBsZW5ndGgsIHBvcnQsIGFkZHJlc3MsIGNhbGxiYWNrXSA9IGFyZ3NcclxuICAgICAgbGV0IGxpc3RcclxuXHJcbiAgICAgIGlmIChhZGRyZXNzIHx8IChwb3J0ICYmIHR5cGVvZiBwb3J0ICE9PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICAgICAgYnVmZmVyID0gc2xpY2VCdWZmZXIoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjayA9IHBvcnRcclxuICAgICAgICBwb3J0ID0gb2Zmc2V0XHJcbiAgICAgICAgYWRkcmVzcyA9IGxlbmd0aFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnVmZmVyKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBsaXN0ID0gW0J1ZmZlci5mcm9tKGJ1ZmZlcildXHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNVaW50OEFycmF5KGJ1ZmZlcikpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcclxuICAgICAgICAgICAgXCJidWZmZXJcIixcclxuICAgICAgICAgICAgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICAgICAgYnVmZmVyXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxpc3QgPSBbYnVmZmVyXVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICghKGxpc3QgPSBmaXhCdWZmZXJMaXN0KGJ1ZmZlcikpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxyXG4gICAgICAgICAgXCJidWZmZXIgbGlzdCBhcmd1bWVudHNcIixcclxuICAgICAgICAgIFtcIkJ1ZmZlclwiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICAgIGJ1ZmZlclxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG5cclxuICAgICAgcG9ydCA9IHBvcnQgPj4+IDBcclxuICAgICAgaWYgKHBvcnQgPT09IDAgfHwgcG9ydCA+IDY1NTM1KSB0aHJvdyBuZXcgRVJSX1NPQ0tFVF9CQURfUE9SVChwb3J0KVxyXG5cclxuICAgICAgLy8gTm9ybWFsaXplIGNhbGxiYWNrIHNvIGl0J3MgZWl0aGVyIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkIGJ1dCBub3QgYW55dGhpbmdcclxuICAgICAgLy8gZWxzZS5cclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IHVuZGVmaW5lZFxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBjYWxsYmFjayA9IGFkZHJlc3NcclxuICAgICAgICBhZGRyZXNzID0gdW5kZWZpbmVkXHJcbiAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcImFkZHJlc3NcIiwgW1wic3RyaW5nXCIsIFwiZmFsc3lcIl0sIGFkZHJlc3MpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9iaW5kU3RhdGUgPT09IEJpbmQuQklORF9TVEFURV9VTkJPVU5EKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kKHsgcG9ydDogMCwgZXhjbHVzaXZlOiB0cnVlIH0sIG51bGwpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGxpc3QucHVzaChCdWZmZXIuYWxsb2MoMCkpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhvc3QgPSBhZGRyZXNzIHx8ICh0aGlzLnR5cGUgPT09IFwidWRwNFwiID8gXCIxMjcuMC4wLjFcIiA6IFwiOjoxXCIpXHJcbiAgICAgIHRoaXMuc2NoZWR1bGUobmV3IFNlbmQodGhpcywgbGlzdCwgcG9ydCwgaG9zdCwgY2FsbGJhY2spKVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlKGNhbGxiYWNrPzogQ2xvc2VMaXN0ZW5lcikge1xyXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgY2FsbGJhY2spXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc2NoZWR1bGUobmV3IENsb3NlKHRoaXMpKVxyXG4gICAgfVxyXG5cclxuICAgIHNjaGVkdWxlKHRhc2s6IFRhc2spIHtcclxuICAgICAgdGhpcy53b3JrUXVldWUucHVzaCh0YXNrKVxyXG4gICAgICBpZiAodGhpcy5pc0lkbGUpIHtcclxuICAgICAgICB0aGlzLmF3YWtlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgYXdha2UoKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzSWRsZSkge1xyXG4gICAgICAgIHRoaXMuaXNJZGxlID0gZmFsc2VcclxuICAgICAgICBjb25zdCB7IHdvcmtRdWV1ZSB9ID0gdGhpc1xyXG4gICAgICAgIGxldCBpbmRleCA9IDBcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCB3b3JrUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb25zdCB0YXNrID0gd29ya1F1ZXVlW2luZGV4KytdXHJcbiAgICAgICAgICBhd2FpdCB0YXNrLnBlcmZvcm0oKVxyXG4gICAgICAgIH1cclxuICAgICAgICB3b3JrUXVldWUubGVuZ3RoID0gMFxyXG4gICAgICAgIHRoaXMuaXNJZGxlID0gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkcmVzcygpIHtcclxuICAgICAgY29uc3QgeyBob3N0LCBwb3J0LCBmYW1pbHkgfSA9IHRoaXMuX2hlYWx0aENoZWNrKCkuYWRkcmVzc1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZHJlc3M6IGhvc3QsXHJcbiAgICAgICAgaG9zdCxcclxuICAgICAgICBwb3J0LFxyXG4gICAgICAgIGZhbWlseTogdG9Ob2RlRmFtaWx5KGZhbWlseSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldE11bHRpY2FzdExvb3BiYWNrKGZsYWc6IGJvb2xlYW4pIHtcclxuICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5faGVhbHRoQ2hlY2soKVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsaWIuVURQU29ja2V0LnNldE11bHRpY2FzdExvb3BiYWNrKHNvY2tldCwgZmxhZylcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJzZXRNdWx0aWNhc3RMb29wYmFja1wiKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TXVsdGljYXN0SW50ZXJmYWNlKGludGVyZmFjZUFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLl9oZWFsdGhDaGVjaygpXHJcblxyXG4gICAgICBpZiAodHlwZW9mIGludGVyZmFjZUFkZHJlc3MgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXHJcbiAgICAgICAgICBcImludGVyZmFjZUFkZHJlc3NcIixcclxuICAgICAgICAgIFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBpbnRlcmZhY2VBZGRyZXNzXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxpYi5VRFBTb2NrZXQuc2V0TXVsdGljYXN0SW50ZXJmYWNlKHNvY2tldCwgaW50ZXJmYWNlQWRkcmVzcylcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJzZXRNdWx0aWNhc3RJbnRlcmZhY2VcIilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldE11bHRpY2FzdFRUTCh0dGw6IG51bWJlcikge1xyXG4gICAgICAvLyBub29wXHJcbiAgICB9XHJcblxyXG4gICAgYWRkTWVtYmVyc2hpcChtdWx0aWNhc3RBZGRyZXNzOiBzdHJpbmcsIGludGVyZmFjZUFkZHJlc3M/OiBzdHJpbmcpIHtcclxuICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5faGVhbHRoQ2hlY2soKVxyXG5cclxuICAgICAgaWYgKCFtdWx0aWNhc3RBZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoXCJtdWx0aWNhc3RBZGRyZXNzXCIpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGliLlVEUFNvY2tldC5hZGRNZW1iZXJzaGlwKHNvY2tldCwgbXVsdGljYXN0QWRkcmVzcywgaW50ZXJmYWNlQWRkcmVzcylcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJhZGRNZW1iZXJzaGlwXCIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGRyb3BNZW1iZXJzaGlwKG11bHRpY2FzdEFkZHJlc3M6IHN0cmluZywgaW50ZXJmYWNlQWRkcmVzczogP3N0cmluZykge1xyXG4gICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLl9oZWFsdGhDaGVjaygpXHJcblxyXG4gICAgICBpZiAoIW11bHRpY2FzdEFkZHJlc3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUyhcIm11bHRpY2FzdEFkZHJlc3NcIilcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsaWIuVURQU29ja2V0LmRyb3BNZW1iZXJzaGlwKFxyXG4gICAgICAgICAgc29ja2V0LFxyXG4gICAgICAgICAgbXVsdGljYXN0QWRkcmVzcyxcclxuICAgICAgICAgIGludGVyZmFjZUFkZHJlc3MgfHwgdW5kZWZpbmVkXHJcbiAgICAgICAgKVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRocm93IGVycm5vRXhjZXB0aW9uKGVycm9yLCBcImRyb3BNZW1iZXJzaGlwXCIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiaW5kKC4uLmFyZ3M6ICopIHtcclxuICAgICAgbGV0IFtwb3J0XywgYWRkcmVzc18sIGNhbGxiYWNrXSA9IGFyZ3NcclxuICAgICAgbGV0IHBvcnQgPSBwb3J0X1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2JpbmRTdGF0ZSAhPT0gQmluZC5CSU5EX1NUQVRFX1VOQk9VTkQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCgpXHJcblxyXG4gICAgICB0aGlzLl9iaW5kU3RhdGUgPSBCaW5kLkJJTkRfU1RBVEVfQklORElOR1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggJiZcclxuICAgICAgICB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgIClcclxuICAgICAgICB0aGlzLm9uY2UoXCJsaXN0ZW5pbmdcIiwgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSlcclxuXHJcbiAgICAgIHZhciBhZGRyZXNzXHJcbiAgICAgIHZhciBleGNsdXNpdmVcclxuXHJcbiAgICAgIGlmIChwb3J0ICE9PSBudWxsICYmIHR5cGVvZiBwb3J0ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgYWRkcmVzcyA9IHBvcnQuYWRkcmVzcyB8fCBcIlwiXHJcbiAgICAgICAgZXhjbHVzaXZlID0gISFwb3J0LmV4Y2x1c2l2ZVxyXG4gICAgICAgIHBvcnQgPSBwb3J0LnBvcnRcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRyZXNzID0gdHlwZW9mIGFkZHJlc3NfID09PSBcImZ1bmN0aW9uXCIgPyBcIlwiIDogYWRkcmVzc19cclxuICAgICAgICBleGNsdXNpdmUgPSBmYWxzZVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkZWZhdWx0aW5nIGFkZHJlc3MgZm9yIGJpbmQgdG8gYWxsIGludGVyZmFjZXNcclxuICAgICAgaWYgKCFhZGRyZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJ1ZHA0XCIpIGFkZHJlc3MgPSBcIjAuMC4wLjBcIlxyXG4gICAgICAgIGVsc2UgYWRkcmVzcyA9IFwiOjpcIlxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNjaGVkdWxlKG5ldyBTcGF3bih0aGlzLCBhZGRyZXNzLCBwb3J0KSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGFzcyBTcGF3biB7XHJcbiAgICBzb2NrZXQ6IFNvY2tldFxyXG4gICAgYWRkcmVzczogc3RyaW5nXHJcbiAgICBwb3J0OiBudW1iZXJcclxuICAgIGNvbnN0cnVjdG9yKHNvY2tldDogU29ja2V0LCBhZGRyZXNzOiBzdHJpbmcsIHBvcnQ6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxyXG4gICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXHJcbiAgICAgIHRoaXMucG9ydCA9IHBvcnRcclxuICAgIH1cclxuICAgIGFzeW5jIHBlcmZvcm0oKSB7XHJcbiAgICAgIGNvbnN0IHsgc29ja2V0LCBhZGRyZXNzLCBwb3J0IH0gPSB0aGlzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGF3YWl0IGJyb3dzZXIuRE5TLnJlc29sdmUoYWRkcmVzcywgMCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NSZXVzZSA9IHNvY2tldC5fcmV1c2VBZGRyXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9XHJcbiAgICAgICAgICBwb3J0ICE9IHVuZGVmaW5lZCAmJiBwb3J0ICE9PSAwXHJcbiAgICAgICAgICAgID8geyBob3N0LCBwb3J0LCBhZGRyZXNzUmV1c2UgfVxyXG4gICAgICAgICAgICA6IHsgaG9zdCwgYWRkcmVzc1JldXNlIH1cclxuXHJcbiAgICAgICAgY29uc3QgX2hhbmRsZSA9IGF3YWl0IGxpYi5VRFBTb2NrZXQuY3JlYXRlKG9wdGlvbnMpXHJcbiAgICAgICAgc29ja2V0Ll9oYW5kbGUgPSBfaGFuZGxlXHJcbiAgICAgICAgc29ja2V0LmVtaXQoXCJsaXN0ZW5pbmdcIiwgdGhpcylcclxuICAgICAgICBsaXN0ZW4oc29ja2V0LCBfaGFuZGxlKVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHNvY2tldC5fYmluZFN0YXRlID0gQmluZC5CSU5EX1NUQVRFX1VOQk9VTkRcclxuICAgICAgICBzb2NrZXQuZW1pdChcImVycm9yXCIsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNsYXNzIFNlbmQge1xyXG4gICAgc29ja2V0OiBTb2NrZXRcclxuICAgIGxpc3Q6IEJ1ZmZlcltdXHJcbiAgICBwb3J0OiBudW1iZXJcclxuICAgIGFkZHJlc3M6IHN0cmluZ1xyXG4gICAgY2FsbGJhY2s6ID8oP0Vycm9yKSA9PiB2b2lkXHJcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQ6IFNvY2tldCwgbGlzdCwgcG9ydDogbnVtYmVyLCBhZGRyZXNzOiBzdHJpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XHJcbiAgICAgIHRoaXMubGlzdCA9IGxpc3RcclxuICAgICAgdGhpcy5wb3J0ID0gcG9ydFxyXG4gICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXHJcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcGVyZm9ybSgpIHtcclxuICAgICAgY29uc3QgeyBzb2NrZXQsIGxpc3QsIHBvcnQsIGFkZHJlc3MsIGNhbGxiYWNrIH0gPSB0aGlzXHJcbiAgICAgIGNvbnN0IHsgX2hhbmRsZSB9ID0gc29ja2V0XHJcbiAgICAgIGNvbnN0IGhvc3QgPSBhd2FpdCBicm93c2VyLkROUy5yZXNvbHZlKGFkZHJlc3MsIDAsIGZhbHNlKVxyXG5cclxuICAgICAgaWYgKF9oYW5kbGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCB7IGJ1ZmZlciB9IG9mIGxpc3QpIHtcclxuICAgICAgICAgICAgYXdhaXQgbGliLlVEUFNvY2tldC5zZW5kKF9oYW5kbGUsIGhvc3QsIHBvcnQsIGJ1ZmZlcilcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBcyBmYXIgYXMgSSBjYW4gdGVsbCB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCB3aGVuIHNlbmQgbWVzc2FnZVxyXG4gICAgICAgICAgLy8gd2FzIGRyYWluZWQgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvODY4OTc4NTk5MTM0MDNiNjg4MjlkYmY5YTE1NGY1YTg3YzRiMDYzOC9kb20vd2ViaWRsL1VEUFNvY2tldC53ZWJpZGwjTDM5XHJcbiAgICAgICAgICAvLyBUaGVyZSBmb3Igd2UganVzdCB3YWl0IDIwbXMgaW5zdGVhZC5cclxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjApKVxyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGFzcyBDbG9zZSB7XHJcbiAgICBzb2NrZXQ6IFNvY2tldFxyXG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XHJcbiAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XHJcbiAgICB9XHJcbiAgICBhc3luYyBwZXJmb3JtKCkge1xyXG4gICAgICBjb25zdCB7IHNvY2tldCB9ID0gdGhpc1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHNvY2tldC5faGVhbHRoQ2hlY2soKVxyXG4gICAgICAgIHNvY2tldC5faGFuZGxlID0gbnVsbFxyXG4gICAgICAgIGF3YWl0IGxpYi5VRFBTb2NrZXQuY2xvc2UoaGFuZGxlKVxyXG4gICAgICAgIC8vIHNvY2tldC5lbWl0KFwiY2xvc2VcIilcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBzb2NrZXQuZW1pdChcImVycm9yXCIsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBsaXN0ZW4gPSBhc3luYyBmdW5jdGlvbihzb2NrZXQsIGhhbmRsZSkge1xyXG4gICAgZm9yIGF3YWl0IChjb25zdCB7IGRhdGEsIGZyb20gfSBvZiBsaWIuVURQU29ja2V0Lm1lc3NhZ2VzKGhhbmRsZSkpIHtcclxuICAgICAgc29ja2V0LmVtaXQoXCJtZXNzYWdlXCIsIEJ1ZmZlci5mcm9tKGRhdGEpLCB7XHJcbiAgICAgICAgYWRkcmVzczogZnJvbS5ob3N0LFxyXG4gICAgICAgIGZhbWlseTogdG9Ob2RlRmFtaWx5KGZyb20uZmFtaWx5KSxcclxuICAgICAgICBwb3J0OiBmcm9tLnBvcnQsXHJcbiAgICAgICAgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBzb2NrZXQuZW1pdChcImNsb3NlXCIpXHJcbiAgfVxyXG5cclxuICBjb25zdCBjcmVhdGVTb2NrZXQgPSAoXHJcbiAgICBvcHRpb25zOiBOb2RlU29ja2V0T3B0aW9ucyB8IFNvY2tldFR5cGUsXHJcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZFxyXG4gICkgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBTb2NrZXQob3B0aW9ucywgY2FsbGJhY2spXHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBjcmVhdGVTb2NrZXQsIFNvY2tldCB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xyXG4gIGFzc2VydCh0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIsIFwiYHRoaW5nYCBoYXMgdG8gYmUgb2YgdHlwZSBzdHJpbmdcIilcclxuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcclxuICAgIGNvbnN0IGxlbiA9IGV4cGVjdGVkLmxlbmd0aFxyXG4gICAgYXNzZXJ0KGxlbiA+IDAsIFwiQXQgbGVhc3Qgb25lIGV4cGVjdGVkIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZFwiKVxyXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoaSA9PiBTdHJpbmcoaSkpXHJcbiAgICBpZiAobGVuID4gMikge1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKFwiLCBcIil9LCBvciBgICtcclxuICAgICAgICBleHBlY3RlZFtsZW4gLSAxXVxyXG4gICAgICApXHJcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xyXG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfSBvciAke2V4cGVjdGVkWzFdfWBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX1gXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtTdHJpbmcoZXhwZWN0ZWQpfWBcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9JTlZBTElEX0FSR19UWVBFIGV4dGVuZHMgVHlwZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XHJcbiAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xyXG4gICAgbGV0IGRldGVybWluZXJcclxuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09IFwic3RyaW5nXCIgJiYgZXhwZWN0ZWQuc3RhcnRzV2l0aChcIm5vdCBcIikpIHtcclxuICAgICAgZGV0ZXJtaW5lciA9IFwibXVzdCBub3QgYmVcIlxyXG4gICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgXCJcIilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRldGVybWluZXIgPSBcIm11c3QgYmVcIlxyXG4gICAgfVxyXG5cclxuICAgIGxldCBtc2dcclxuICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiIGFyZ3VtZW50XCIpKSB7XHJcbiAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcclxuICAgICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgXCJ0eXBlXCIpfWBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKFwiLlwiKSA/IFwicHJvcGVydHlcIiA6IFwiYXJndW1lbnRcIlxyXG4gICAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCBcInR5cGVcIil9YFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXHJcbiAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxyXG4gICAgc3VwZXIobXNnKVxyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgRVJSX01JU1NJTkdfQVJHUyBleHRlbmRzIFR5cGVFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoLi4ucGFyYW1zKSB7XHJcbiAgICBsZXQgbXNnID0gXCJUaGUgXCJcclxuICAgIGNvbnN0IGxlbiA9IHBhcmFtcy5sZW5ndGhcclxuICAgIGNvbnN0IGFyZ3MgPSBwYXJhbXMubWFwKGEgPT4gYFwiJHthfVwiYClcclxuICAgIHN3aXRjaCAobGVuKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBtc2cgKz0gYCR7YXJnc1swXX0gYXJndW1lbnRgXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIG1zZyArPSBgJHthcmdzWzBdfSBhbmQgJHthcmdzWzFdfSBhcmd1bWVudHNgXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKFwiLCBcIilcclxuICAgICAgICBtc2cgKz0gYCwgYW5kICR7YXJnc1tsZW4gLSAxXX0gYXJndW1lbnRzYFxyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgICBzdXBlcihgJHttc2d9IG11c3QgYmUgc3BlY2lmaWVkYClcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiU29ja2V0IGlzIGFscmVhZHkgYm91bmRcIilcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9TT0NLRVRfQkFEX0JVRkZFUl9TSVpFIGV4dGVuZHMgVHlwZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIilcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9TT0NLRVRfQkFEX1BPUlQgZXh0ZW5kcyBSYW5nZUVycm9yIHtcclxuICBjb25zdHJ1Y3Rvcihwb3J0KSB7XHJcbiAgICBzdXBlcihcIlBvcnQgc2hvdWxkIGJlID4gMCBhbmQgPCA2NTUzNi4gUmVjZWl2ZWQgJHtwb3J0fS5cIilcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9TT0NLRVRfQkFEX1RZUEUgZXh0ZW5kcyBUeXBlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJCYWQgc29ja2V0IHR5cGUgc3BlY2lmaWVkLiBWYWxpZCB0eXBlcyBhcmU6IHVkcDQsIHVkcDZcIilcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEVSUl9TT0NLRVRfQlVGRkVSX1NJWkUgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkNvdWxkIG5vdCBnZXQgb3Igc2V0IGJ1ZmZlciBzaXplXCIpXHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBFUlJfU09DS0VUX0NBTk5PVF9TRU5EIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJVbmFibGUgdG8gc2VuZCBkYXRhXCIpXHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBFUlJfU09DS0VUX0RHUkFNX05PVF9SVU5OSU5HIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJOb3QgcnVubmluZ1wiKVxyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgU3lzdGVtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29kZTogbnVtYmVyXHJcbiAgc3lzY2FsbDogc3RyaW5nXHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3lzY2FsbCkge1xyXG4gICAgc3VwZXIobWVzc2FnZSlcclxuICAgIHRoaXMuY29kZSA9IGNvZGVcclxuICAgIHRoaXMuc3lzY2FsbCA9IHN5c2NhbGxcclxuICB9XHJcbiAgZ2V0IGVycm5vKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29kZVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgZXJybm9FeGNlcHRpb24gPSAoZXJyLCBzeXNjYWxsLCBvcmlnaW5hbCkgPT4ge1xyXG4gIGNvbnN0IGNvZGUgPSBlcnIubWVzc2FnZVxyXG4gIGNvbnN0IG1lc3NhZ2UgPSBvcmlnaW5hbFxyXG4gICAgPyBgJHtzeXNjYWxsfSAke2NvZGV9ICR7b3JpZ2luYWx9YFxyXG4gICAgOiBgJHtzeXNjYWxsfSAke2NvZGV9YFxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICBjb25zdCBleCA9IG5ldyBTeXN0ZW1FcnJvcihtZXNzYWdlLCBjb2RlLCBzeXNjYWxsKVxyXG5cclxuICByZXR1cm4gZXhcclxufVxyXG5cclxuZnVuY3Rpb24gc2xpY2VCdWZmZXIoc291cmNlLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIGxldCBidWZmZXIgPSBzb3VyY2VcclxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKVxyXG4gIH0gZWxzZSBpZiAoIWlzVWludDhBcnJheShidWZmZXIpKSB7XHJcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXHJcbiAgICAgIFwiYnVmZmVyXCIsXHJcbiAgICAgIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIiwgXCJzdHJpbmdcIl0sXHJcbiAgICAgIGJ1ZmZlclxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnQgPSBvZmZzZXQgPj4+IDBcclxuICBjb25zdCBlbmQgPSBzdGFydCArIChsZW5ndGggPj4+IDApXHJcblxyXG4gIHJldHVybiBidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZClcclxufVxyXG5cclxuZnVuY3Rpb24gZml4QnVmZmVyTGlzdChsaXN0KSB7XHJcbiAgY29uc3QgbmV3bGlzdCA9IG5ldyBBcnJheShsaXN0Lmxlbmd0aClcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cclxuICAgIGlmICh0eXBlb2YgYnVmID09PSBcInN0cmluZ1wiKSBuZXdsaXN0W2ldID0gQnVmZmVyLmZyb20oYnVmKVxyXG4gICAgZWxzZSBpZiAoIWlzVWludDhBcnJheShidWYpKSByZXR1cm4gbnVsbFxyXG4gICAgZWxzZSBuZXdsaXN0W2ldID0gYnVmXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3bGlzdFxyXG59XHJcblxyXG5jb25zdCB0b05vZGVGYW1pbHkgPSBmYW1pbHkgPT4gKGZhbWlseSA9PT0gMiA/IFwidWRwNlwiIDogXCJ1ZHA0XCIpXHJcblxyXG5pbnRlcmZhY2UgTG9va3VwIHtcclxuICAoaG9zdG5hbWU6IHN0cmluZywgTG9va3VwQ2FsbGJhY2spOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTG9va3VwQ2FsbGJhY2sge1xyXG4gICg/RXJyb3IsIGFkZHJlc3M6IHN0cmluZywgZmFtaWx5OiA0IHwgNik6IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IGZyb21Ob2RlTG9va3VwID0gKGxvb2t1cDogTG9va3VwKSA9PiAoe1xyXG4gIHJlc29sdmU6IChob3N0bmFtZTogc3RyaW5nKSA9PlxyXG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBsb29rdXAoaG9zdG5hbWUsIChlcnJvciwgYWRkcmVzcywgZmFtaWx5KSA9PiB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICByZWplY3QoZXJyb3IpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUoeyBhZGRyZXNzZXM6IFthZGRyZXNzXSB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH0pXHJcbn0pXHJcbiJdfQ==