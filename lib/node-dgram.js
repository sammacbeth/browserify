"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _buffer = require("buffer");

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isUint8Array = value => value instanceof Uint8Array;

const Bind = {
  BIND_STATE_UNBOUND: 0,
  BIND_STATE_BINDING: 1,
  BIND_STATE_BOUND: 2
};

exports.default = lib => {
  class Socket extends _events2.default {
    constructor(type, listener) {
      super();

      if (type !== null && typeof type === "object") {
        var options = type;
        this.type = options.type;
        this.dns = options.lookup ? fromNodeLookup(options.lookup) : lib.dns;
        this._reuseAddr = !!options.reuseAddr;
      } else {
        this._reuseAddr = false;
        this.type = type;
        this.dns = lib.dns;
      }

      if (typeof listener === "function") {
        this.on("message", listener);
      }

      this.isIdle = true;
      this._handle = null;
      this._bindState = Bind.BIND_STATE_UNBOUND;
      this.workQueue = [];
    }
    _healthCheck() {
      if (!this._handle) {
        throw new ERR_SOCKET_DGRAM_NOT_RUNNING();
      }
      return this._handle;
    }

    send(buffer, ...args) {
      let [offset, length, port, address, callback] = args;
      let list;

      if (address || port && typeof port !== "function") {
        buffer = sliceBuffer(buffer, offset, length);
      } else {
        callback = port;
        port = offset;
        address = length;
      }

      if (!Array.isArray(buffer)) {
        if (typeof buffer === "string") {
          list = [_buffer.Buffer.from(buffer)];
        } else if (!isUint8Array(buffer)) {
          throw new ERR_INVALID_ARG_TYPE("buffer", ["Buffer", "Uint8Array", "string"], buffer);
        } else {
          list = [buffer];
        }
      } else if (!(list = fixBufferList(buffer))) {
        throw new ERR_INVALID_ARG_TYPE("buffer list arguments", ["Buffer", "string"], buffer);
      }

      port = port >>> 0;
      if (port === 0 || port > 65535) throw new ERR_SOCKET_BAD_PORT(port);

      if (typeof callback !== "function") callback = undefined;

      if (typeof address === "function") {
        callback = address;
        address = undefined;
      } else if (address && typeof address !== "string") {
        throw new ERR_INVALID_ARG_TYPE("address", ["string", "falsy"], address);
      }

      if (this._bindState === Bind.BIND_STATE_UNBOUND) {
        this.bind({ port: 0, exclusive: true }, null);
      }

      if (list.length === 0) {
        list.push(_buffer.Buffer.alloc(0));
      }

      const host = address || (this.type === "udp4" ? "127.0.0.1" : "::1");
      this.schedule(new Send(this, list, port, host, callback));
    }

    close(callback) {
      if (typeof callback === "function") {
        this.on("close", callback);
      }

      this.schedule(new Close(this));
    }

    schedule(task) {
      this.workQueue.push(task);
      if (this.isIdle) {
        this.awake();
      }
    }
    async awake() {
      if (this.isIdle) {
        this.isIdle = false;
        const { workQueue } = this;
        let index = 0;
        while (index < workQueue.length) {
          const task = workQueue[index++];
          await task.perform();
        }
        workQueue.length = 0;
        this.isIdle = true;
      }
    }

    address() {
      const { address, port, family } = this._healthCheck().address;
      return {
        address,
        host: address,
        port,
        family: toNodeFamily(family)
      };
    }

    setMulticastLoopback(flag) {
      const socket = this._healthCheck();

      try {
        socket.setMulticastLoopback(flag);
      } catch (error) {
        throw errnoException(error, "setMulticastLoopback");
      }
    }

    setMulticastInterface(interfaceAddress) {
      const socket = this._healthCheck();

      if (typeof interfaceAddress !== "string") {
        throw new ERR_INVALID_ARG_TYPE("interfaceAddress", "string", interfaceAddress);
      }

      try {
        socket.setMulticastInterface(interfaceAddress);
      } catch (error) {
        throw errnoException(error, "setMulticastInterface");
      }
    }

    setMulticastTTL(ttl) {}

    addMembership(multicastAddress, interfaceAddress) {
      const socket = this._healthCheck();

      if (!multicastAddress) {
        throw new ERR_MISSING_ARGS("multicastAddress");
      }

      try {
        socket.joinMulticast(multicastAddress, interfaceAddress);
      } catch (error) {
        throw errnoException(error, "addMembership");
      }
    }
    dropMembership(multicastAddress, interfaceAddress) {
      const socket = this._healthCheck();

      if (!multicastAddress) {
        throw new ERR_MISSING_ARGS("multicastAddress");
      }

      try {
        socket.leaveMulticast(multicastAddress, interfaceAddress || undefined);
      } catch (error) {
        throw errnoException(error, "dropMembership");
      }
    }

    bind(...args) {
      let [port_, address_, callback] = args;
      let port = port_;

      if (this._bindState !== Bind.BIND_STATE_UNBOUND) throw new ERR_SOCKET_ALREADY_BOUND();

      this._bindState = Bind.BIND_STATE_BINDING;

      if (arguments.length && typeof arguments[arguments.length - 1] === "function") this.once("listening", arguments[arguments.length - 1]);

      var address;
      var exclusive;

      if (port !== null && typeof port === "object") {
        address = port.address || "";
        exclusive = !!port.exclusive;
        port = port.port;
      } else {
        address = typeof address_ === "function" ? "" : address_;
        exclusive = false;
      }

      if (!address) {
        if (this.type === "udp4") address = "0.0.0.0";else address = "::";
      }

      this.schedule(new Spawn(this, address, port));

      return this;
    }
  }

  class Spawn {
    constructor(socket, address, port) {
      this.socket = socket;
      this.address = address;
      this.port = port;
    }
    async perform() {
      const { socket, address, port } = this;
      try {
        const record = await socket.dns.resolve(address);
        const host = record.addresses[0];
        const addressReuse = socket._reuseAddr;
        const options = port != undefined && port !== 0 ? { host, port, addressReuse } : { host, addressReuse };

        const _handle = await lib.UDPSocket.create(options);
        socket._handle = _handle;
        socket.emit("listening", this);
        listen(socket, _handle);
      } catch (error) {
        socket._bindState = Bind.BIND_STATE_UNBOUND;
        socket.emit("error", error);
      }
    }
  }
  class Send {
    constructor(socket, list, port, address, callback) {
      this.socket = socket;
      this.list = list;
      this.port = port;
      this.address = address;
      this.callback = callback;
    }
    async perform() {
      const { socket, list, port, address, callback } = this;
      const { _handle } = socket;
      const host = (await socket.dns.resolve(address)).addresses[0];

      if (_handle) {
        try {
          for (const { buffer } of list) {
            await _handle.send(host, port, buffer);
          }

          if (callback) {
            await new Promise(resolve => setTimeout(resolve, 20));
            callback(null);
          }
        } catch (error) {
          if (callback) {
            callback(error);
          }
        }
      }
    }
  }

  class Close {
    constructor(socket) {
      this.socket = socket;
    }
    async perform() {
      const { socket } = this;
      try {
        const handle = socket._healthCheck();
        socket._handle = null;
        await handle.close();
      } catch (error) {
        socket.emit("error", error);
      }
    }
  }

  const listen = async function (socket, handle) {
    for await (const [data, from] of handle.messages()) {
      socket.emit("message", _buffer.Buffer.from(data), {
        address: from.address,
        family: toNodeFamily(from.family),
        port: from.port,
        size: data.byteLength
      });
    }
    socket.emit("close");
  };

  const createSocket = (options, callback) => {
    return new Socket(options, callback);
  };

  return { createSocket, Socket };
};

function oneOf(expected, thing) {
  (0, _assert2.default)(typeof thing === "string", "`thing` has to be of type string");
  if (Array.isArray(expected)) {
    const len = expected.length;
    (0, _assert2.default)(len > 0, "At least one expected value needs to be specified");
    expected = expected.map(i => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class ERR_INVALID_ARG_TYPE extends TypeError {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.startsWith("not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }

    let msg;
    if (name.endsWith(" argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }

    msg += `. Received type ${typeof actual}`;
    super(msg);
  }
}

class ERR_MISSING_ARGS extends TypeError {
  constructor(...params) {
    let msg = "The ";
    const len = params.length;
    const args = params.map(a => `"${a}"`);
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super(`${msg} must be specified`);
  }
}

class ERR_SOCKET_ALREADY_BOUND extends Error {
  constructor() {
    super("Socket is already bound");
  }
}

class ERR_SOCKET_BAD_BUFFER_SIZE extends TypeError {
  constructor() {
    super("Buffer size must be a positive integer");
  }
}

class ERR_SOCKET_BAD_PORT extends RangeError {
  constructor(port) {
    super("Port should be > 0 and < 65536. Received ${port}.");
  }
}

class ERR_SOCKET_BAD_TYPE extends TypeError {
  constructor() {
    super("Bad socket type specified. Valid types are: udp4, udp6");
  }
}

class ERR_SOCKET_BUFFER_SIZE extends Error {
  constructor() {
    super("Could not get or set buffer size");
  }
}

class ERR_SOCKET_CANNOT_SEND extends Error {
  constructor() {
    super("Unable to send data");
  }
}

class ERR_SOCKET_DGRAM_NOT_RUNNING extends Error {
  constructor() {
    super("Not running");
  }
}

class SystemError extends Error {
  constructor(message, code, syscall) {
    super(message);
    this.code = code;
    this.syscall = syscall;
  }
  get errno() {
    return this.code;
  }
}

const errnoException = (err, syscall, original) => {
  const code = err.message;
  const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;

  const ex = new SystemError(message, code, syscall);

  return ex;
};

function sliceBuffer(source, offset, length) {
  let buffer = source;
  if (typeof buffer === "string") {
    buffer = _buffer.Buffer.from(buffer);
  } else if (!isUint8Array(buffer)) {
    throw new ERR_INVALID_ARG_TYPE("buffer", ["Buffer", "Uint8Array", "string"], buffer);
  }

  const start = offset >>> 0;
  const end = start + (length >>> 0);

  return buffer.slice(start, end);
}

function fixBufferList(list) {
  const newlist = new Array(list.length);

  for (var i = 0, l = list.length; i < l; i++) {
    var buf = list[i];
    if (typeof buf === "string") newlist[i] = _buffer.Buffer.from(buf);else if (!isUint8Array(buf)) return null;else newlist[i] = buf;
  }

  return newlist;
}

const toNodeFamily = family => family === 2 ? "udp6" : "udp4";

const fromNodeLookup = lookup => ({
  resolve: hostname => new Promise((resolve, reject) => {
    lookup(hostname, (error, address, family) => {
      if (error) {
        reject(error);
      } else {
        resolve({ addresses: [address] });
      }
    });
  })
});
module.exports = exports["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ub2RlLWRncmFtLmpzIl0sIm5hbWVzIjpbImlzVWludDhBcnJheSIsInZhbHVlIiwiVWludDhBcnJheSIsIkJpbmQiLCJCSU5EX1NUQVRFX1VOQk9VTkQiLCJCSU5EX1NUQVRFX0JJTkRJTkciLCJCSU5EX1NUQVRFX0JPVU5EIiwibGliIiwiU29ja2V0IiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwibGlzdGVuZXIiLCJvcHRpb25zIiwiZG5zIiwibG9va3VwIiwiZnJvbU5vZGVMb29rdXAiLCJfcmV1c2VBZGRyIiwicmV1c2VBZGRyIiwib24iLCJpc0lkbGUiLCJfaGFuZGxlIiwiX2JpbmRTdGF0ZSIsIndvcmtRdWV1ZSIsIl9oZWFsdGhDaGVjayIsIkVSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkciLCJzZW5kIiwiYnVmZmVyIiwiYXJncyIsIm9mZnNldCIsImxlbmd0aCIsInBvcnQiLCJhZGRyZXNzIiwiY2FsbGJhY2siLCJsaXN0Iiwic2xpY2VCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJCdWZmZXIiLCJmcm9tIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJmaXhCdWZmZXJMaXN0IiwiRVJSX1NPQ0tFVF9CQURfUE9SVCIsInVuZGVmaW5lZCIsImJpbmQiLCJleGNsdXNpdmUiLCJwdXNoIiwiYWxsb2MiLCJob3N0Iiwic2NoZWR1bGUiLCJTZW5kIiwiY2xvc2UiLCJDbG9zZSIsInRhc2siLCJhd2FrZSIsImluZGV4IiwicGVyZm9ybSIsImZhbWlseSIsInRvTm9kZUZhbWlseSIsInNldE11bHRpY2FzdExvb3BiYWNrIiwiZmxhZyIsInNvY2tldCIsImVycm9yIiwiZXJybm9FeGNlcHRpb24iLCJzZXRNdWx0aWNhc3RJbnRlcmZhY2UiLCJpbnRlcmZhY2VBZGRyZXNzIiwic2V0TXVsdGljYXN0VFRMIiwidHRsIiwiYWRkTWVtYmVyc2hpcCIsIm11bHRpY2FzdEFkZHJlc3MiLCJFUlJfTUlTU0lOR19BUkdTIiwiam9pbk11bHRpY2FzdCIsImRyb3BNZW1iZXJzaGlwIiwibGVhdmVNdWx0aWNhc3QiLCJwb3J0XyIsImFkZHJlc3NfIiwiRVJSX1NPQ0tFVF9BTFJFQURZX0JPVU5EIiwiYXJndW1lbnRzIiwib25jZSIsIlNwYXduIiwicmVjb3JkIiwicmVzb2x2ZSIsImFkZHJlc3NlcyIsImFkZHJlc3NSZXVzZSIsIlVEUFNvY2tldCIsImNyZWF0ZSIsImVtaXQiLCJsaXN0ZW4iLCJQcm9taXNlIiwic2V0VGltZW91dCIsImhhbmRsZSIsImRhdGEiLCJtZXNzYWdlcyIsInNpemUiLCJieXRlTGVuZ3RoIiwiY3JlYXRlU29ja2V0Iiwib25lT2YiLCJleHBlY3RlZCIsInRoaW5nIiwibGVuIiwibWFwIiwiaSIsIlN0cmluZyIsInNsaWNlIiwiam9pbiIsIlR5cGVFcnJvciIsIm5hbWUiLCJhY3R1YWwiLCJkZXRlcm1pbmVyIiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJtc2ciLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwicGFyYW1zIiwiYSIsIkVycm9yIiwiRVJSX1NPQ0tFVF9CQURfQlVGRkVSX1NJWkUiLCJSYW5nZUVycm9yIiwiRVJSX1NPQ0tFVF9CQURfVFlQRSIsIkVSUl9TT0NLRVRfQlVGRkVSX1NJWkUiLCJFUlJfU09DS0VUX0NBTk5PVF9TRU5EIiwiU3lzdGVtRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsInN5c2NhbGwiLCJlcnJubyIsImVyciIsIm9yaWdpbmFsIiwiZXgiLCJzb3VyY2UiLCJzdGFydCIsImVuZCIsIm5ld2xpc3QiLCJsIiwiYnVmIiwiaG9zdG5hbWUiLCJyZWplY3QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQU9BOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGVBQWVDLFNBQVNBLGlCQUFpQkMsVUFBL0M7O0FBRUEsTUFBTUMsT0FBTztBQUNYQyxzQkFBb0IsQ0FEVDtBQUVYQyxzQkFBb0IsQ0FGVDtBQUdYQyxvQkFBa0I7QUFIUCxDQUFiOztrQkFrRWdCQyxHQUFELElBQWM7QUFDM0Is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QUNMbUIsZ0JBQVEsRUFBRUMsV0FBVyxDQUFDbEQsT0FBRCxDQUFiLEVBQVI7QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJEO0FBRndDLENBQXJCLENBQXZCIiwiZmlsZSI6Im5vZGUtZGdyYW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7XG4gIFVEUFNvY2tldE1hbmFnZXIsXG4gIFVEUFNvY2tldCxcbiAgU29ja2V0T3B0aW9uc1xufSBmcm9tIFwibGliZHdlYi9zcmMvdG9vbGtpdC9jb21wb25lbnRzL2V4dGVuc2lvbnMvaW50ZXJmYWNlL3VkcFwiXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIlxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIlxuXG5jb25zdCBpc1VpbnQ4QXJyYXkgPSB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcblxuY29uc3QgQmluZCA9IHtcbiAgQklORF9TVEFURV9VTkJPVU5EOiAwLFxuICBCSU5EX1NUQVRFX0JJTkRJTkc6IDEsXG4gIEJJTkRfU1RBVEVfQk9VTkQ6IDJcbn1cblxudHlwZSBCaW5kU3RhdGUgPSAkVmFsdWVzPHR5cGVvZiBCaW5kPlxuXG4vLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvZG5zL3Jlc29sdmVcblxuaW50ZXJmYWNlIEROUyB7XG4gIHJlc29sdmUoaG9zdG5hbWU6IHN0cmluZywgZmxhZ3M/OiBETlNSZXNvbHZlRmxhZ1tdKTogUHJvbWlzZTxETlNSZWNvcmQ+O1xufVxuXG50eXBlIEROU1Jlc29sdmVGbGFnID1cbiAgfCBcImFsbG93X25hbWVfY29sbGlzaW9uc1wiXG4gIHwgXCJieXBhc3NfY2FjaGVcIlxuICB8IFwiY2Fub25pY2FsX25hbWVcIlxuICB8IFwiZGlzYWJsZV9pcHY0XCJcbiAgfCBcImRpc2FibGVfaXB2NlwiXG4gIHwgXCJkaXNhYmxlX3RyclwiXG4gIHwgXCJvZmZsaW5lXCJcbiAgfCBcInByaW9yaXR5X2xvd1wiXG4gIHwgXCJwcmlvcml0eV9tZWRpdW1cIlxuICB8IFwic3BlY3VsYXRlXCJcblxuaW50ZXJmYWNlIEROU1JlY29yZCB7XG4gIGFkZHJlc3Nlczogc3RyaW5nW107XG4gIGNhbm9uaWNhbE5hbWU/OiBzdHJpbmc7XG4gIGlzVFJSOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgTGliIHtcbiAgVURQU29ja2V0OiBVRFBTb2NrZXRNYW5hZ2VyO1xuICBkbnM6IEROUztcbn1cblxuaW50ZXJmYWNlIE5vZGVTb2NrZXRPcHRpb25zIHtcbiAgdHlwZTogU29ja2V0VHlwZTtcbiAgcmV1c2VBZGRyPzogYm9vbGVhbjtcbiAgcmVjdkJ1ZmZlclNpemU/OiBudW1iZXI7XG4gIHNlbmRCdWZmZXJTaXplPzogbnVtYmVyO1xuICBsb29rdXA/OiAoaG9zdG5hbWU6IHN0cmluZywgKGVycm9yOiA/RXJyb3IsIHN0cmluZywgc3RyaW5nKSA9PiB2b2lkKSA9PiB2b2lkO1xufVxuXG50eXBlIFNvY2tldFR5cGUgPSBcInVkcDRcIiB8IFwidWRwNlwiXG5cbmludGVyZmFjZSBUYXNrIHtcbiAgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5pbnRlcmZhY2UgTWVzc2FnZUxpc3RlbmVyIHtcbiAgKFxuICAgIG1zZzogQnVmZmVyLFxuICAgIHJpbmZvOiB7IGFkZHJlc3M6IHN0cmluZywgZmFtaWx5OiBzdHJpbmcsIHBvcnQ6IG51bWJlciwgc2l6ZTogbnVtYmVyIH1cbiAgKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIEJpbmRMaXN0ZW5lciB7XG4gICgpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgQ2xvc2VMaXN0ZW5lciB7XG4gICgpOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAobGliOiBMaWIpID0+IHtcbiAgY2xhc3MgU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBfaGFuZGxlOiA/VURQU29ja2V0XG4gICAgaXNJZGxlOiBib29sZWFuXG4gICAgX2JpbmRTdGF0ZTogQmluZFN0YXRlXG4gICAgX3JldXNlQWRkcjogYm9vbGVhblxuICAgIGRuczogeyByZXNvbHZlKHN0cmluZyk6IFByb21pc2U8eyBhZGRyZXNzZXM6IHN0cmluZ1tdIH0+IH1cbiAgICB3b3JrUXVldWU6IFRhc2tbXVxuICAgIHR5cGU6IFNvY2tldFR5cGVcbiAgICBsaXN0ZW5lcjogP01lc3NhZ2VMaXN0ZW5lclxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgdHlwZTogU29ja2V0VHlwZSB8IE5vZGVTb2NrZXRPcHRpb25zLFxuICAgICAgbGlzdGVuZXI6IE1lc3NhZ2VMaXN0ZW5lclxuICAgICkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVcbiAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlXG4gICAgICAgIHRoaXMuZG5zID0gb3B0aW9ucy5sb29rdXAgPyBmcm9tTm9kZUxvb2t1cChvcHRpb25zLmxvb2t1cCkgOiBsaWIuZG5zXG4gICAgICAgIHRoaXMuX3JldXNlQWRkciA9ICEhb3B0aW9ucy5yZXVzZUFkZHJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JldXNlQWRkciA9IGZhbHNlXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAgICAgdGhpcy5kbnMgPSBsaWIuZG5zXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uKFwibWVzc2FnZVwiLCBsaXN0ZW5lcilcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0lkbGUgPSB0cnVlXG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsXG4gICAgICB0aGlzLl9iaW5kU3RhdGUgPSBCaW5kLkJJTkRfU1RBVEVfVU5CT1VORFxuICAgICAgdGhpcy53b3JrUXVldWUgPSBbXVxuICAgIH1cbiAgICBfaGVhbHRoQ2hlY2soKTogVURQU29ja2V0IHtcbiAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZnJvbSBkZ3JhbV9sZWdhY3kuanMuXG4gICAgICAgIHRocm93IG5ldyBFUlJfU09DS0VUX0RHUkFNX05PVF9SVU5OSU5HKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVcbiAgICB9XG5cbiAgICBzZW5kKGJ1ZmZlcjogQnVmZmVyLCAuLi5hcmdzOiAqKSB7XG4gICAgICBsZXQgW29mZnNldCwgbGVuZ3RoLCBwb3J0LCBhZGRyZXNzLCBjYWxsYmFja10gPSBhcmdzXG4gICAgICBsZXQgbGlzdFxuXG4gICAgICBpZiAoYWRkcmVzcyB8fCAocG9ydCAmJiB0eXBlb2YgcG9ydCAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICBidWZmZXIgPSBzbGljZUJ1ZmZlcihidWZmZXIsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBwb3J0XG4gICAgICAgIHBvcnQgPSBvZmZzZXRcbiAgICAgICAgYWRkcmVzcyA9IGxlbmd0aFxuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGxpc3QgPSBbQnVmZmVyLmZyb20oYnVmZmVyKV1cbiAgICAgICAgfSBlbHNlIGlmICghaXNVaW50OEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgICBcImJ1ZmZlclwiLFxuICAgICAgICAgICAgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiLCBcInN0cmluZ1wiXSxcbiAgICAgICAgICAgIGJ1ZmZlclxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ID0gW2J1ZmZlcl1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKGxpc3QgPSBmaXhCdWZmZXJMaXN0KGJ1ZmZlcikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICBcImJ1ZmZlciBsaXN0IGFyZ3VtZW50c1wiLFxuICAgICAgICAgIFtcIkJ1ZmZlclwiLCBcInN0cmluZ1wiXSxcbiAgICAgICAgICBidWZmZXJcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBwb3J0ID0gcG9ydCA+Pj4gMFxuICAgICAgaWYgKHBvcnQgPT09IDAgfHwgcG9ydCA+IDY1NTM1KSB0aHJvdyBuZXcgRVJSX1NPQ0tFVF9CQURfUE9SVChwb3J0KVxuXG4gICAgICAvLyBOb3JtYWxpemUgY2FsbGJhY2sgc28gaXQncyBlaXRoZXIgYSBmdW5jdGlvbiBvciB1bmRlZmluZWQgYnV0IG5vdCBhbnl0aGluZ1xuICAgICAgLy8gZWxzZS5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSB1bmRlZmluZWRcblxuICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhZGRyZXNzXG4gICAgICAgIGFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXCJhZGRyZXNzXCIsIFtcInN0cmluZ1wiLCBcImZhbHN5XCJdLCBhZGRyZXNzKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYmluZFN0YXRlID09PSBCaW5kLkJJTkRfU1RBVEVfVU5CT1VORCkge1xuICAgICAgICB0aGlzLmJpbmQoeyBwb3J0OiAwLCBleGNsdXNpdmU6IHRydWUgfSwgbnVsbClcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxpc3QucHVzaChCdWZmZXIuYWxsb2MoMCkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhvc3QgPSBhZGRyZXNzIHx8ICh0aGlzLnR5cGUgPT09IFwidWRwNFwiID8gXCIxMjcuMC4wLjFcIiA6IFwiOjoxXCIpXG4gICAgICB0aGlzLnNjaGVkdWxlKG5ldyBTZW5kKHRoaXMsIGxpc3QsIHBvcnQsIGhvc3QsIGNhbGxiYWNrKSlcbiAgICB9XG5cbiAgICBjbG9zZShjYWxsYmFjaz86IENsb3NlTGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgY2FsbGJhY2spXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NoZWR1bGUobmV3IENsb3NlKHRoaXMpKVxuICAgIH1cblxuICAgIHNjaGVkdWxlKHRhc2s6IFRhc2spIHtcbiAgICAgIHRoaXMud29ya1F1ZXVlLnB1c2godGFzaylcbiAgICAgIGlmICh0aGlzLmlzSWRsZSkge1xuICAgICAgICB0aGlzLmF3YWtlKClcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYXdha2UoKSB7XG4gICAgICBpZiAodGhpcy5pc0lkbGUpIHtcbiAgICAgICAgdGhpcy5pc0lkbGUgPSBmYWxzZVxuICAgICAgICBjb25zdCB7IHdvcmtRdWV1ZSB9ID0gdGhpc1xuICAgICAgICBsZXQgaW5kZXggPSAwXG4gICAgICAgIHdoaWxlIChpbmRleCA8IHdvcmtRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0YXNrID0gd29ya1F1ZXVlW2luZGV4KytdXG4gICAgICAgICAgYXdhaXQgdGFzay5wZXJmb3JtKClcbiAgICAgICAgfVxuICAgICAgICB3b3JrUXVldWUubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmlzSWRsZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRyZXNzKCkge1xuICAgICAgY29uc3QgeyBhZGRyZXNzLCBwb3J0LCBmYW1pbHkgfSA9IHRoaXMuX2hlYWx0aENoZWNrKCkuYWRkcmVzc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgaG9zdDogYWRkcmVzcyxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgZmFtaWx5OiB0b05vZGVGYW1pbHkoZmFtaWx5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldE11bHRpY2FzdExvb3BiYWNrKGZsYWc6IGJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuX2hlYWx0aENoZWNrKClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc29ja2V0LnNldE11bHRpY2FzdExvb3BiYWNrKGZsYWcpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJzZXRNdWx0aWNhc3RMb29wYmFja1wiKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldE11bHRpY2FzdEludGVyZmFjZShpbnRlcmZhY2VBZGRyZXNzOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuX2hlYWx0aENoZWNrKClcblxuICAgICAgaWYgKHR5cGVvZiBpbnRlcmZhY2VBZGRyZXNzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICBcImludGVyZmFjZUFkZHJlc3NcIixcbiAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgIGludGVyZmFjZUFkZHJlc3NcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBzb2NrZXQuc2V0TXVsdGljYXN0SW50ZXJmYWNlKGludGVyZmFjZUFkZHJlc3MpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJzZXRNdWx0aWNhc3RJbnRlcmZhY2VcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRNdWx0aWNhc3RUVEwodHRsOiBudW1iZXIpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG5cbiAgICBhZGRNZW1iZXJzaGlwKG11bHRpY2FzdEFkZHJlc3M6IHN0cmluZywgaW50ZXJmYWNlQWRkcmVzcz86IHN0cmluZykge1xuICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5faGVhbHRoQ2hlY2soKVxuXG4gICAgICBpZiAoIW11bHRpY2FzdEFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoXCJtdWx0aWNhc3RBZGRyZXNzXCIpXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNvY2tldC5qb2luTXVsdGljYXN0KG11bHRpY2FzdEFkZHJlc3MsIGludGVyZmFjZUFkZHJlc3MpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJub0V4Y2VwdGlvbihlcnJvciwgXCJhZGRNZW1iZXJzaGlwXCIpXG4gICAgICB9XG4gICAgfVxuICAgIGRyb3BNZW1iZXJzaGlwKG11bHRpY2FzdEFkZHJlc3M6IHN0cmluZywgaW50ZXJmYWNlQWRkcmVzczogP3N0cmluZykge1xuICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5faGVhbHRoQ2hlY2soKVxuXG4gICAgICBpZiAoIW11bHRpY2FzdEFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoXCJtdWx0aWNhc3RBZGRyZXNzXCIpXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNvY2tldC5sZWF2ZU11bHRpY2FzdChcbiAgICAgICAgICBtdWx0aWNhc3RBZGRyZXNzLFxuICAgICAgICAgIGludGVyZmFjZUFkZHJlc3MgfHwgdW5kZWZpbmVkXG4gICAgICAgIClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm5vRXhjZXB0aW9uKGVycm9yLCBcImRyb3BNZW1iZXJzaGlwXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYmluZCguLi5hcmdzOiAqKSB7XG4gICAgICBsZXQgW3BvcnRfLCBhZGRyZXNzXywgY2FsbGJhY2tdID0gYXJnc1xuICAgICAgbGV0IHBvcnQgPSBwb3J0X1xuXG4gICAgICBpZiAodGhpcy5fYmluZFN0YXRlICE9PSBCaW5kLkJJTkRfU1RBVEVfVU5CT1VORClcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCgpXG5cbiAgICAgIHRoaXMuX2JpbmRTdGF0ZSA9IEJpbmQuQklORF9TVEFURV9CSU5ESU5HXG5cbiAgICAgIGlmIChcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICApXG4gICAgICAgIHRoaXMub25jZShcImxpc3RlbmluZ1wiLCBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKVxuXG4gICAgICB2YXIgYWRkcmVzc1xuICAgICAgdmFyIGV4Y2x1c2l2ZVxuXG4gICAgICBpZiAocG9ydCAhPT0gbnVsbCAmJiB0eXBlb2YgcG9ydCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBhZGRyZXNzID0gcG9ydC5hZGRyZXNzIHx8IFwiXCJcbiAgICAgICAgZXhjbHVzaXZlID0gISFwb3J0LmV4Y2x1c2l2ZVxuICAgICAgICBwb3J0ID0gcG9ydC5wb3J0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzID0gdHlwZW9mIGFkZHJlc3NfID09PSBcImZ1bmN0aW9uXCIgPyBcIlwiIDogYWRkcmVzc19cbiAgICAgICAgZXhjbHVzaXZlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gZGVmYXVsdGluZyBhZGRyZXNzIGZvciBiaW5kIHRvIGFsbCBpbnRlcmZhY2VzXG4gICAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJ1ZHA0XCIpIGFkZHJlc3MgPSBcIjAuMC4wLjBcIlxuICAgICAgICBlbHNlIGFkZHJlc3MgPSBcIjo6XCJcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2hlZHVsZShuZXcgU3Bhd24odGhpcywgYWRkcmVzcywgcG9ydCkpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgU3Bhd24ge1xuICAgIHNvY2tldDogU29ja2V0XG4gICAgYWRkcmVzczogc3RyaW5nXG4gICAgcG9ydDogbnVtYmVyXG4gICAgY29uc3RydWN0b3Ioc29ja2V0OiBTb2NrZXQsIGFkZHJlc3M6IHN0cmluZywgcG9ydDogbnVtYmVyKSB7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzc1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydFxuICAgIH1cbiAgICBhc3luYyBwZXJmb3JtKCkge1xuICAgICAgY29uc3QgeyBzb2NrZXQsIGFkZHJlc3MsIHBvcnQgfSA9IHRoaXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHNvY2tldC5kbnMucmVzb2x2ZShhZGRyZXNzKVxuICAgICAgICBjb25zdCBob3N0ID0gcmVjb3JkLmFkZHJlc3Nlc1swXVxuICAgICAgICBjb25zdCBhZGRyZXNzUmV1c2UgPSBzb2NrZXQuX3JldXNlQWRkclxuICAgICAgICBjb25zdCBvcHRpb25zID1cbiAgICAgICAgICBwb3J0ICE9IHVuZGVmaW5lZCAmJiBwb3J0ICE9PSAwXG4gICAgICAgICAgICA/IHsgaG9zdCwgcG9ydCwgYWRkcmVzc1JldXNlIH1cbiAgICAgICAgICAgIDogeyBob3N0LCBhZGRyZXNzUmV1c2UgfVxuXG4gICAgICAgIGNvbnN0IF9oYW5kbGUgPSBhd2FpdCBsaWIuVURQU29ja2V0LmNyZWF0ZShvcHRpb25zKVxuICAgICAgICBzb2NrZXQuX2hhbmRsZSA9IF9oYW5kbGVcbiAgICAgICAgc29ja2V0LmVtaXQoXCJsaXN0ZW5pbmdcIiwgdGhpcylcbiAgICAgICAgbGlzdGVuKHNvY2tldCwgX2hhbmRsZSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNvY2tldC5fYmluZFN0YXRlID0gQmluZC5CSU5EX1NUQVRFX1VOQk9VTkRcbiAgICAgICAgc29ja2V0LmVtaXQoXCJlcnJvclwiLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgU2VuZCB7XG4gICAgc29ja2V0OiBTb2NrZXRcbiAgICBsaXN0OiBCdWZmZXJbXVxuICAgIHBvcnQ6IG51bWJlclxuICAgIGFkZHJlc3M6IHN0cmluZ1xuICAgIGNhbGxiYWNrOiA/KD9FcnJvcikgPT4gdm9pZFxuICAgIGNvbnN0cnVjdG9yKHNvY2tldDogU29ja2V0LCBsaXN0LCBwb3J0OiBudW1iZXIsIGFkZHJlc3M6IHN0cmluZywgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgICB0aGlzLmxpc3QgPSBsaXN0XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0XG4gICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB9XG4gICAgYXN5bmMgcGVyZm9ybSgpIHtcbiAgICAgIGNvbnN0IHsgc29ja2V0LCBsaXN0LCBwb3J0LCBhZGRyZXNzLCBjYWxsYmFjayB9ID0gdGhpc1xuICAgICAgY29uc3QgeyBfaGFuZGxlIH0gPSBzb2NrZXRcbiAgICAgIGNvbnN0IGhvc3QgPSAoYXdhaXQgc29ja2V0LmRucy5yZXNvbHZlKGFkZHJlc3MpKS5hZGRyZXNzZXNbMF1cblxuICAgICAgaWYgKF9oYW5kbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgYnVmZmVyIH0gb2YgbGlzdCkge1xuICAgICAgICAgICAgYXdhaXQgX2hhbmRsZS5zZW5kKGhvc3QsIHBvcnQsIGJ1ZmZlcilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBcyBmYXIgYXMgSSBjYW4gdGVsbCB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCB3aGVuIHNlbmQgbWVzc2FnZVxuICAgICAgICAgIC8vIHdhcyBkcmFpbmVkIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzg2ODk3ODU5OTEzNDAzYjY4ODI5ZGJmOWExNTRmNWE4N2M0YjA2MzgvZG9tL3dlYmlkbC9VRFBTb2NrZXQud2ViaWRsI0wzOVxuICAgICAgICAgIC8vIFRoZXJlIGZvciB3ZSBqdXN0IHdhaXQgMjBtcyBpbnN0ZWFkLlxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwKSlcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQ2xvc2Uge1xuICAgIHNvY2tldDogU29ja2V0XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIH1cbiAgICBhc3luYyBwZXJmb3JtKCkge1xuICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IHRoaXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHNvY2tldC5faGVhbHRoQ2hlY2soKVxuICAgICAgICBzb2NrZXQuX2hhbmRsZSA9IG51bGxcbiAgICAgICAgYXdhaXQgaGFuZGxlLmNsb3NlKClcbiAgICAgICAgLy8gc29ja2V0LmVtaXQoXCJjbG9zZVwiKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc29ja2V0LmVtaXQoXCJlcnJvclwiLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBsaXN0ZW4gPSBhc3luYyBmdW5jdGlvbihzb2NrZXQsIGhhbmRsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgW2RhdGEsIGZyb21dIG9mIGhhbmRsZS5tZXNzYWdlcygpKSB7XG4gICAgICBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgQnVmZmVyLmZyb20oZGF0YSksIHtcbiAgICAgICAgYWRkcmVzczogZnJvbS5hZGRyZXNzLFxuICAgICAgICBmYW1pbHk6IHRvTm9kZUZhbWlseShmcm9tLmZhbWlseSksXG4gICAgICAgIHBvcnQ6IGZyb20ucG9ydCxcbiAgICAgICAgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICBzb2NrZXQuZW1pdChcImNsb3NlXCIpXG4gIH1cblxuICBjb25zdCBjcmVhdGVTb2NrZXQgPSAoXG4gICAgb3B0aW9uczogTm9kZVNvY2tldE9wdGlvbnMgfCBTb2NrZXRUeXBlLFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICkgPT4ge1xuICAgIHJldHVybiBuZXcgU29ja2V0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICB9XG5cbiAgcmV0dXJuIHsgY3JlYXRlU29ja2V0LCBTb2NrZXQgfVxufVxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgYXNzZXJ0KHR5cGVvZiB0aGluZyA9PT0gXCJzdHJpbmdcIiwgXCJgdGhpbmdgIGhhcyB0byBiZSBvZiB0eXBlIHN0cmluZ1wiKVxuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICBjb25zdCBsZW4gPSBleHBlY3RlZC5sZW5ndGhcbiAgICBhc3NlcnQobGVuID4gMCwgXCJBdCBsZWFzdCBvbmUgZXhwZWN0ZWQgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkXCIpXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoaSA9PiBTdHJpbmcoaSkpXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKFwiLCBcIil9LCBvciBgICtcbiAgICAgICAgZXhwZWN0ZWRbbGVuIC0gMV1cbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX0gb3IgJHtleHBlY3RlZFsxXX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX1gXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtTdHJpbmcoZXhwZWN0ZWQpfWBcbiAgfVxufVxuXG5jbGFzcyBFUlJfSU5WQUxJRF9BUkdfVFlQRSBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICAgIGxldCBkZXRlcm1pbmVyXG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gXCJzdHJpbmdcIiAmJiBleHBlY3RlZC5zdGFydHNXaXRoKFwibm90IFwiKSkge1xuICAgICAgZGV0ZXJtaW5lciA9IFwibXVzdCBub3QgYmVcIlxuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sIFwiXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGVybWluZXIgPSBcIm11c3QgYmVcIlxuICAgIH1cblxuICAgIGxldCBtc2dcbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIiBhcmd1bWVudFwiKSkge1xuICAgICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgXCJ0eXBlXCIpfWBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IG5hbWUuaW5jbHVkZXMoXCIuXCIpID8gXCJwcm9wZXJ0eVwiIDogXCJhcmd1bWVudFwiXG4gICAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCBcInR5cGVcIil9YFxuICAgIH1cblxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG4gICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgICBzdXBlcihtc2cpXG4gIH1cbn1cblxuY2xhc3MgRVJSX01JU1NJTkdfQVJHUyBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKC4uLnBhcmFtcykge1xuICAgIGxldCBtc2cgPSBcIlRoZSBcIlxuICAgIGNvbnN0IGxlbiA9IHBhcmFtcy5sZW5ndGhcbiAgICBjb25zdCBhcmdzID0gcGFyYW1zLm1hcChhID0+IGBcIiR7YX1cImApXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbXNnICs9IGAke2FyZ3NbMF19IGFyZ3VtZW50YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtc2cgKz0gYCR7YXJnc1swXX0gYW5kICR7YXJnc1sxXX0gYXJndW1lbnRzYFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbihcIiwgXCIpXG4gICAgICAgIG1zZyArPSBgLCBhbmQgJHthcmdzW2xlbiAtIDFdfSBhcmd1bWVudHNgXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHN1cGVyKGAke21zZ30gbXVzdCBiZSBzcGVjaWZpZWRgKVxuICB9XG59XG5cbmNsYXNzIEVSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJTb2NrZXQgaXMgYWxyZWFkeSBib3VuZFwiKVxuICB9XG59XG5cbmNsYXNzIEVSUl9TT0NLRVRfQkFEX0JVRkZFUl9TSVpFIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKVxuICB9XG59XG5cbmNsYXNzIEVSUl9TT0NLRVRfQkFEX1BPUlQgZXh0ZW5kcyBSYW5nZUVycm9yIHtcbiAgY29uc3RydWN0b3IocG9ydCkge1xuICAgIHN1cGVyKFwiUG9ydCBzaG91bGQgYmUgPiAwIGFuZCA8IDY1NTM2LiBSZWNlaXZlZCAke3BvcnR9LlwiKVxuICB9XG59XG5cbmNsYXNzIEVSUl9TT0NLRVRfQkFEX1RZUEUgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkJhZCBzb2NrZXQgdHlwZSBzcGVjaWZpZWQuIFZhbGlkIHR5cGVzIGFyZTogdWRwNCwgdWRwNlwiKVxuICB9XG59XG5cbmNsYXNzIEVSUl9TT0NLRVRfQlVGRkVSX1NJWkUgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQ291bGQgbm90IGdldCBvciBzZXQgYnVmZmVyIHNpemVcIilcbiAgfVxufVxuXG5jbGFzcyBFUlJfU09DS0VUX0NBTk5PVF9TRU5EIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlVuYWJsZSB0byBzZW5kIGRhdGFcIilcbiAgfVxufVxuXG5jbGFzcyBFUlJfU09DS0VUX0RHUkFNX05PVF9SVU5OSU5HIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIk5vdCBydW5uaW5nXCIpXG4gIH1cbn1cblxuY2xhc3MgU3lzdGVtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IG51bWJlclxuICBzeXNjYWxsOiBzdHJpbmdcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3lzY2FsbCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuc3lzY2FsbCA9IHN5c2NhbGxcbiAgfVxuICBnZXQgZXJybm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZVxuICB9XG59XG5cbmNvbnN0IGVycm5vRXhjZXB0aW9uID0gKGVyciwgc3lzY2FsbCwgb3JpZ2luYWwpID0+IHtcbiAgY29uc3QgY29kZSA9IGVyci5tZXNzYWdlXG4gIGNvbnN0IG1lc3NhZ2UgPSBvcmlnaW5hbFxuICAgID8gYCR7c3lzY2FsbH0gJHtjb2RlfSAke29yaWdpbmFsfWBcbiAgICA6IGAke3N5c2NhbGx9ICR7Y29kZX1gXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGNvbnN0IGV4ID0gbmV3IFN5c3RlbUVycm9yKG1lc3NhZ2UsIGNvZGUsIHN5c2NhbGwpXG5cbiAgcmV0dXJuIGV4XG59XG5cbmZ1bmN0aW9uIHNsaWNlQnVmZmVyKHNvdXJjZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGJ1ZmZlciA9IHNvdXJjZVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAgfSBlbHNlIGlmICghaXNVaW50OEFycmF5KGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICBcImJ1ZmZlclwiLFxuICAgICAgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiLCBcInN0cmluZ1wiXSxcbiAgICAgIGJ1ZmZlclxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gb2Zmc2V0ID4+PiAwXG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgKGxlbmd0aCA+Pj4gMClcblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGZpeEJ1ZmZlckxpc3QobGlzdCkge1xuICBjb25zdCBuZXdsaXN0ID0gbmV3IEFycmF5KGxpc3QubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICh0eXBlb2YgYnVmID09PSBcInN0cmluZ1wiKSBuZXdsaXN0W2ldID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIGVsc2UgaWYgKCFpc1VpbnQ4QXJyYXkoYnVmKSkgcmV0dXJuIG51bGxcbiAgICBlbHNlIG5ld2xpc3RbaV0gPSBidWZcbiAgfVxuXG4gIHJldHVybiBuZXdsaXN0XG59XG5cbmNvbnN0IHRvTm9kZUZhbWlseSA9IGZhbWlseSA9PiAoZmFtaWx5ID09PSAyID8gXCJ1ZHA2XCIgOiBcInVkcDRcIilcblxuaW50ZXJmYWNlIExvb2t1cCB7XG4gIChob3N0bmFtZTogc3RyaW5nLCBMb29rdXBDYWxsYmFjayk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBMb29rdXBDYWxsYmFjayB7XG4gICg/RXJyb3IsIGFkZHJlc3M6IHN0cmluZywgZmFtaWx5OiA0IHwgNik6IHZvaWQ7XG59XG5cbmNvbnN0IGZyb21Ob2RlTG9va3VwID0gKGxvb2t1cDogTG9va3VwKSA9PiAoe1xuICByZXNvbHZlOiAoaG9zdG5hbWU6IHN0cmluZykgPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb29rdXAoaG9zdG5hbWUsIChlcnJvciwgYWRkcmVzcywgZmFtaWx5KSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHsgYWRkcmVzc2VzOiBbYWRkcmVzc10gfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxufSlcbiJdfQ==